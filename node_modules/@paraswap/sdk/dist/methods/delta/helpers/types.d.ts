import type { MarkOptional } from 'ts-essentials';
export type DeltaAuctionOrder = {
    /** @description The address of the order owner */
    owner: string;
    /** @description The address of the order beneficiary */
    beneficiary: string;
    /** @description The address of the src token */
    srcToken: string;
    /** @description The address of the dest token */
    destToken: string;
    /** @description The amount of src token to swap */
    srcAmount: string;
    /** @description The minimum amount of dest token to receive */
    destAmount: string;
    /** @description The expected amount of dest token to receive */
    expectedDestAmount: string;
    /** @description The deadline for the order */
    deadline: number;
    /** @description The nonce of the order */
    nonce: string;
    /** @description Optional permit signature for the src token */
    permit: string;
    /** @description Encoded partner address, fee bps, and flags for the order. partnerAndFee = (partner << 96) | (partnerTakesSurplus << 8) | fee in bps (max fee is 2%) */
    partnerAndFee: string;
    /** @description The bridge input */
    bridge: Bridge;
};
export type Bridge = {
    maxRelayerFee: string;
    destinationChainId: number;
    /** @description The address of the output token. Same as Order.destToken but on destination chain, so can still be a different address */
    outputToken: string;
    /** @description The address of the multiCallHandler on destination chain, used to unwrap WETH and send to Smart Contract receiver. Must be non-zero when receiver address is a SmartContract wallet and need to send Native ETH */
    multiCallHandler: string;
};
export type BridgeInput = MarkOptional<Bridge, 'multiCallHandler'>;
type DeltaAuctionStatus = 'NOT_STARTED' | 'POSTED' | 'RUNNING' | 'EXECUTING' | 'EXECUTED' | 'FAILED' | 'EXPIRED';
type DeltaAuctionTransaction = {
    id: string;
    hash: string;
    orderId: string;
    bidId: string | null;
    blockNumber: number;
    blockHash: string;
    gasUsed: bigint;
    gasPrice: bigint;
    blobGasUsed: bigint;
    blobGasPrice: bigint;
    index: number;
    status: number;
    from: string;
    to: string;
    receivedAmount: string;
    receivedAmountUSD: number;
    spentAmount: string;
    spentAmountUSD: number;
    filledPercent: number;
    protocolFee: string;
    partnerFee: string;
    agent: string;
    auctionId: string;
};
export type ParaswapDeltaAuction = {
    id: string;
    deltaVersion: string;
    user: string;
    signature: string;
    status: DeltaAuctionStatus;
    order: DeltaAuctionOrder;
    orderHash: string | null;
    transactions: DeltaAuctionTransaction[];
    chainId: number;
    partner: string;
    referrerAddress: string | null;
    expiresAt: string;
    createdAt: string;
    updatedAt: string;
    partiallyFillable: boolean;
    excludeAgents: string[] | null;
    includeAgents: string[] | null;
    bridgeMetadata: BridgeMetadata | null;
    bridgeStatus: BridgeStatus | null;
};
export type BridgeMetadata = {
    /** @description The amount that user should expect to get */
    outputAmount: string;
    /** @description The cross-chain deadline. If deadline passes, the bridgeStatus would be expired */
    fillDeadline: number;
    /** @description The deposit id */
    depositId: number;
    /** @description The transaction hash on the destination chain that fulfilled the order. When bridgeStatus='filled' */
    fillTx?: string;
    /** @description The transaction hash on the source chain that refunded the deposit. When bridgeStatus='refunded' */
    depositRefundTxHash?: string;
};
export type BridgeStatus = 'pending' | 'filled' | 'expired' | 'refunded';
export {};
//# sourceMappingURL=types.d.ts.map