import { ContractMethodByName } from '../../constants';
import type { ConstructFetchInput, Address, AddressOrSymbol, PriceString, OptimalRate, RequestParameters, EnumerateLiteral } from '../../types';
export declare enum PricingMethod {
    megapath = "megapath",
    multipath = "multipath",
    simplepath = "simplepath"
}
type PricingMethodByName = EnumerateLiteral<typeof PricingMethod>;
export type RateOptions = {
    excludeDEXS?: string[];
    includeDEXS?: string[];
    excludePools?: string[];
    excludePricingMethods?: PricingMethodByName[];
    excludeContractMethods?: ContractMethodByName[];
    includeContractMethods?: ContractMethodByName[];
    partner?: string;
    /** @description In %. It's a way to bypass the API price impact check (default = 15%) */
    maxImpact?: number;
    maxUSDImpact?: number;
    otherExchangePrices?: boolean;
    /** @description proceed with priceRoute building even when tokens don't have USD price. Default: false */
    ignoreBadUsdPrice?: boolean;
    /** @description Exclude all RFQs from pricing, e.g.: AugustusRFQ, Hashflow. Default: false */
    excludeRFQ?: boolean;
    /** @description 	Specify that methods without fee support should be excluded from the price route. Default: false */
    excludeContractMethodsWithoutFeeModel?: boolean;
    /** @description If the source token is a tax token, you should specify the tax amount in BPS.  */
    srcTokenTransferFee?: string;
    /** @description If the destination token is a tax token, you should specify the tax amount in BPS.  */
    destTokenTransferFee?: string;
    /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */
    srcTokenDexTransferFee?: string;
    /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */
    destTokenDexTransferFee?: string;
};
type CommonGetRateInput = {
    amount: PriceString;
    userAddress?: Address;
    side?: 'SELL' | 'BUY';
    options?: RateOptions;
    srcDecimals?: number;
    destDecimals?: number;
};
export type GetRateInput = CommonGetRateInput & {
    srcToken: AddressOrSymbol;
    destToken: AddressOrSymbol;
};
export type GetRate = (options: GetRateInput, requestParams?: RequestParameters) => Promise<OptimalRate>;
type GetRateByRouteInput = CommonGetRateInput & {
    route: AddressOrSymbol[];
};
type GetRateByRoute = (options: GetRateByRouteInput, requestParams?: RequestParameters) => Promise<OptimalRate>;
export type GetRateFunctions = {
    getRate: GetRate;
    getRateByRoute: GetRateByRoute;
};
export declare const constructGetRate: ({ apiURL, version, chainId, fetcher, }: ConstructFetchInput) => GetRateFunctions;
export {};
//# sourceMappingURL=rates.d.ts.map