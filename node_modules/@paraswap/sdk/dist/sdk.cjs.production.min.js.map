{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/helpers/misc.ts","../src/methods/swap/spender.ts","../src/helpers/approve.ts","../src/methods/swap/approve.ts","../src/helpers/token.ts","../src/methods/swap/balance.ts","../src/methods/swap/adapters.ts","../src/methods/swap/helpers/normalizeRateOptions.ts","../src/methods/swap/rates.ts","../src/methods/swap/swapTx.ts","../src/methods/swap/token.ts","../src/methods/common/orders/buildOrderData.ts","../src/methods/common/orders/misc.ts","../src/methods/limitOrders/helpers/misc.ts","../src/methods/nftOrders/helpers/buildOrderData.ts","../src/methods/nftOrders/helpers/misc.ts","../src/methods/swap/transaction.ts","../src/methods/limitOrders/helpers/buildOrderData.ts","../src/methods/limitOrders/buildOrder.ts","../src/methods/limitOrders/signOrder.ts","../src/methods/limitOrders/cancelOrder.ts","../src/methods/common/orders/signature.ts","../src/methods/common/orders/encoding.ts","../src/methods/limitOrders/fillOrderDirectly.ts","../src/methods/limitOrders/getOrders.ts","../src/methods/limitOrders/postOrder.ts","../src/methods/limitOrders/approveForOrder.ts","../src/methods/limitOrders/getOrdersContract.ts","../src/methods/limitOrders/transaction.ts","../src/methods/nftOrders/buildOrder.ts","../src/methods/nftOrders/signOrder.ts","../src/methods/nftOrders/cancelOrder.ts","../src/methods/nftOrders/getOrders.ts","../src/methods/nftOrders/postOrder.ts","../src/methods/nftOrders/getOrdersContract.ts","../src/methods/nftOrders/approveForOrder.ts","../src/methods/nftOrders/transaction.ts","../src/helpers/fetchers/axios.ts","../src/helpers/fetchers/fetch.ts","../src/helpers/providers/ethers.ts","../src/helpers/providers/ethersV6.ts","../src/helpers/providers/helpers.ts","../src/helpers/providers/web3.ts","../src/helpers/providers/viem.ts","../src/methods/delta/getDeltaContract.ts","../src/methods/delta/getPartnerFee.ts","../src/methods/delta/helpers/composePermit.ts","../src/methods/delta/helpers/buildDeltaOrderData.ts","../src/methods/delta/buildDeltaOrder.ts","../src/methods/delta/postDeltaOrder.ts","../src/methods/delta/helpers/misc.ts","../src/methods/delta/signDeltaOrder.ts","../src/methods/delta/getDeltaPrice.ts","../src/methods/delta/getDeltaOrders.ts","../src/methods/delta/approveForDelta.ts","../src/methods/delta/getBridgeInfo.ts","../src/methods/delta/getMulticallHandlers.ts","../src/methods/delta/isTokenSupportedInDelta.ts","../src/methods/quote/getQuote.ts","../src/sdk/partial.ts","../src/methods/swap/index.ts","../src/methods/limitOrders/index.ts","../src/methods/delta/index.ts","../src/methods/nftOrders/index.ts","../src/legacy/index.ts","../src/sdk/full.ts","../src/sdk/simple.ts"],"sourcesContent":["import { EnumerateLiteral, ParaSwapVersionUnion } from './types';\n\nimport type { ContractMethod } from '@paraswap/core';\n\nexport {\n  SwapSide,\n  ContractMethod,\n  ContractMethodV5,\n  ContractMethodV6,\n} from '@paraswap/core';\n\n// allows to pass by name instead of importing enum first\nexport type ContractMethodByName = EnumerateLiteral<typeof ContractMethod>;\n\nexport const API_URL = 'https://api.paraswap.io';\nexport const DEFAULT_VERSION = '6.2' satisfies ParaSwapVersionUnion;\n","import type { Primitive } from 'ts-essentials';\n\nexport const objectToFilledEntries = <T extends Record<string, unknown>>(\n  object: T\n): [string, string][] => {\n  return (\n    Object.entries(object)\n      // removes keys with undefined values\n      .filter(([, value]) => value !== undefined)\n      .map(([key, value]) => [key, String(value)])\n  );\n};\n\nexport const constructSearchString = <\n  //                               not arrays or mappings\n  U extends Record<string, Exclude<Primitive, symbol>>\n>(\n  queryOptions: U\n): `?${string}` | '' => {\n  const queryEntries = objectToFilledEntries(queryOptions);\n\n  const queryString = new URLSearchParams(queryEntries).toString();\n\n  // returns empty string or `?${string}`\n  return queryString && `?${queryString}`;\n};\n\ntype MinAxiosError = {\n  code?: string;\n  request?: any;\n  isAxiosError: boolean;\n  message: string;\n};\n\ntype MinAxiosResponse = {\n  data: any;\n  status: number;\n  statusText: string;\n  headers: Record<string, any>;\n  config: { url?: string; method?: string };\n};\n\ntype FetcherErrorConstructorInput = MinAxiosError & {\n  response?: MinAxiosResponse;\n};\n\nexport interface FetcherErrorInterface extends FetcherErrorConstructorInput {\n  status?: number;\n  code?: string;\n}\n\nexport const isFetcherError = (error: unknown): error is FetcherError => {\n  return error instanceof FetcherError;\n};\n\nexport class FetcherError extends Error implements FetcherErrorInterface {\n  code;\n  status;\n  request;\n  response;\n  isAxiosError = false;\n\n  public constructor({\n    code,\n    request,\n    response,\n    isAxiosError,\n    message,\n  }: FetcherErrorConstructorInput) {\n    super();\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FetcherError);\n    }\n\n    this.name = this.constructor.name;\n    this.code = code;\n    this.request = request;\n    this.isAxiosError = isAxiosError;\n\n    // no response on AxiosError\n    if (!response) {\n      this.message = message;\n      return;\n    }\n\n    this.response = response;\n\n    const { data, status } = response;\n    this.status = status;\n    this.message = isDataWithError(data) ? data.error : message;\n  }\n}\n// to turn `object -> Record` for indexed variable access\nfunction isObject(obj: unknown): obj is Record<string | symbol, any> {\n  return !!obj && typeof obj === 'object';\n}\n\nexport function isDataWithError(data: unknown): data is { error: string } {\n  return isObject(data) && typeof data['error'] === 'string';\n}\n\nexport type ExtractAbiMethodNames<T extends readonly { name: string }[]> =\n  T[number]['name'];\n\n// reduce element[] to Object{key: prop, val?: element}\n// for example\n// gatherObjectsByProp(Token[], token => token.address) => Record<address, Token|undefined>\nexport function gatherObjectsByProp<T>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string\n): Record<string, T>;\nexport function gatherObjectsByProp<T, U>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string,\n  transfrom: (elem: T, accumElem: U | undefined, index: number) => U\n): Record<string, U>;\nexport function gatherObjectsByProp<T, U>(\n  elements: T[],\n  pickProp: (elem: T, index: number) => string,\n  transform?: (elem: T, accumElem: U | undefined, index: number) => U\n): Record<string, T> | Record<string, U> {\n  return elements.reduce<Record<string, T> | Record<string, U>>(\n    (accum, element, index) => {\n      const key = pickProp(element, index);\n\n      const accumElem: T | U | undefined = accum[key];\n      const transformedElement = transform\n        ? //                       if transform is available, can only be U | undefined\n          transform(element, accumElem as U | undefined, index)\n        : element;\n\n      accum[key] = transformedElement;\n\n      return accum;\n    },\n    {}\n  );\n}\n\n// checks that array has at least one element\nexport const isFilledArray = <T>(array: T[]): array is [T, ...T[]] => {\n  return array.length > 0;\n};\n\nexport function getRandomInt(): number {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n}\n\nexport function runOnceAndCache<T, Args extends any[]>(\n  // can pass `(...any[]) => any but null | undefined`\n  func: (...args: Args) => NonNullable<T>\n): (...args: Args) => NonNullable<T> {\n  let result: NonNullable<T>;\n\n  return (...args) => {\n    return result ?? (result = func(...args));\n  };\n}\n\nexport function deriveCompactSignature(signature: string): string {\n  // Remove \"0x\" prefix if present\n  if (signature.startsWith('0x')) {\n    signature = signature.slice(2);\n  }\n\n  // Convert the hex string to a byte array\n  const bytes = new Uint8Array(signature.length / 2);\n  for (let i = 0; i < signature.length; i += 2) {\n    bytes[i / 2] = parseInt(signature.slice(i, i + 2), 16);\n  }\n\n  // Validate the signature length (64 or 65 bytes)\n  if (bytes.length !== 64 && bytes.length !== 65) {\n    throw new Error('Invalid signature length: must be 64 or 65 bytes');\n  }\n\n  // Extract r and s components\n  const r = `0x${Array.from(bytes.slice(0, 32), (b) =>\n    b.toString(16).padStart(2, '0')\n  ).join('')}`;\n  let v;\n\n  // Handle 64-byte (EIP-2098 compact) and 65-byte signatures\n  if (bytes.length === 64) {\n    // Extract v from the highest bit of s and clear the bit in s\n    v = 27 + (bytes[32]! >> 7);\n    bytes[32]! &= 0x7f; // Clear the highest bit\n  } else {\n    // Extract v directly for 65-byte signature\n    v = bytes[64]!;\n\n    // Normalize v to canonical form (27 or 28)\n    if (v < 27) {\n      v += 27;\n    }\n  }\n\n  // Compute yParityAndS (_vs) for the compact signature\n  const sBytes = Array.from(bytes.slice(32, 64));\n  if (v === 28) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    sBytes[0]! |= 0x80; // Set the highest bit if v is 28\n  }\n  const yParityAndS = `0x${sBytes\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')}`;\n\n  // Construct the compact signature by concatenating r and yParityAndS\n  const compactSignature = r + yParityAndS.slice(2);\n\n  return compactSignature;\n}\n","import { API_URL, DEFAULT_VERSION } from '../../constants';\nimport { constructSearchString, runOnceAndCache } from '../../helpers/misc';\nimport type {\n  ConstructFetchInput,\n  Address,\n  RequestParameters,\n} from '../../types';\n\nexport type GetSpender = (\n  requestParams?: RequestParameters\n) => Promise<Address>;\ntype GetContracts = (\n  requestParams?: RequestParameters\n) => Promise<AdaptersContractsResult>;\n\nexport type GetSpenderFunctions = {\n  getSpender: GetSpender;\n  getAugustusSwapper: GetSpender;\n  getAugustusRFQ: GetSpender;\n  getContracts: GetContracts;\n};\n\ninterface AdaptersContractsResult {\n  AugustusSwapper: string;\n  TokenTransferProxy: string;\n  AugustusRFQ: string;\n  Executors: {\n    [key: `Executor${number}`]: string;\n  };\n  ParaswapDelta?: string; // only available on chains with Delta support\n}\n\nexport const constructGetSpender = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetSpenderFunctions => {\n  const search = constructSearchString<{ network: number; version: string }>({\n    network: chainId,\n    version,\n  });\n\n  const fetchURL = `${apiURL}/adapters/contracts${search}` as const;\n\n  const _getContracts: GetContracts = async (requestParams) => {\n    const data = await fetcher<AdaptersContractsResult>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data;\n  };\n\n  // cached for the same instance of `{getContracts, getSpender, getAugustusSwapper, getAugustusRFQ} = constructGetSpender()`\n  // so should persist across same apiUrl & network\n  const getContracts = runOnceAndCache(_getContracts);\n\n  const getSpender: GetSpender = async (requestParams) => {\n    const { TokenTransferProxy } = await getContracts(requestParams);\n    return TokenTransferProxy;\n  };\n\n  const getAugustusSwapper: GetSpender = async (requestParams) => {\n    const { AugustusSwapper } = await getContracts(requestParams);\n    return AugustusSwapper;\n  };\n\n  const getAugustusRFQ: GetSpender = async (requestParams) => {\n    const { AugustusRFQ } = await getContracts(requestParams);\n    return AugustusRFQ;\n  };\n\n  return { getContracts, getSpender, getAugustusSwapper, getAugustusRFQ };\n};\n","import type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n  TxSendOverrides,\n} from '../types';\nimport type { ExtractAbiMethodNames } from '../helpers/misc';\nimport type { Address, PriceString } from './token';\n\n// much smaller than the whole ERC20_ABI\nconst MinERC20Abi = [\n  {\n    constant: false,\n    inputs: [\n      { name: '_spender', type: 'address' },\n      { name: '_value', type: 'uint256' },\n    ],\n    name: 'approve',\n    outputs: [{ name: '', type: 'bool' }],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype ApprovalMethods = ExtractAbiMethodNames<typeof MinERC20Abi>;\n\ntype ApproveContractCaller<T> = ConstructProviderFetchInput<\n  T,\n  'transactCall'\n>['contractCaller'];\n\nexport type ApproveToken<T> = (\n  amount: PriceString,\n  tokenAddress: Address,\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<T>;\n\nexport type GetSpenderAsyncOrSync = (\n  requestParams?: RequestParameters\n) => Address | Promise<Address>;\n\nexport function approveTokenMethodFactory<T>(\n  contractCaller: ApproveContractCaller<T>,\n  getSpender: GetSpenderAsyncOrSync\n): ApproveToken<T> {\n  return async (amount, tokenAddress, overrides = {}, requestParams) => {\n    const spender = await getSpender(requestParams);\n\n    const res = await contractCaller.transactCall<ApprovalMethods>({\n      address: tokenAddress,\n      abi: MinERC20Abi,\n      contractMethod: 'approve',\n      args: [spender, amount],\n      overrides,\n    });\n\n    return res;\n  };\n}\n","import { constructGetSpender } from './spender';\nimport type {\n  ConstructProviderFetchInput,\n  TxSendOverrides,\n  Address,\n  PriceString,\n  RequestParameters,\n} from '../../types';\nimport { ApproveToken, approveTokenMethodFactory } from '../../helpers/approve';\n\ntype ApproveTokenBulk<T> = (\n  amount: PriceString,\n  tokenAddresses: Address[],\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<Awaited<T>[]>;\n\nexport type ApproveTokenFunctions<T> = {\n  approveToken: ApproveToken<T>;\n  approveTokenBulk: ApproveTokenBulk<T>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveToken = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenFunctions<T> => {\n  // getSpender is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getSpender } = constructGetSpender(options);\n\n  const approveToken: ApproveToken<T> = approveTokenMethodFactory<T>(\n    options.contractCaller,\n    getSpender\n  );\n\n  const approveTokenBulk: ApproveTokenBulk<T> = async (\n    amount,\n    tokenAddresses,\n    overrides,\n    requestParams\n  ) => {\n    return Promise.all(\n      tokenAddresses.map((tokenAddress) =>\n        approveToken(amount, tokenAddress, overrides, requestParams)\n      )\n    );\n  };\n\n  return { approveToken, approveTokenBulk };\n};\n","import type { MarkOptional } from 'ts-essentials';\n\n/**\n * @type hex token or account address\n */\nexport type Address = string;\n/**\n * @type hex token address or token symbol\n */\nexport type AddressOrSymbol = string;\n/**\n * @type number in string form\n */\nexport type PriceString = string;\n/**\n * @type transaction hash\n */\nexport type TxHash = `0x${string}`;\n\n// @TODO sync with what it actually is\nexport type LendingToken =\n  | 'cToken'\n  | 'iToken'\n  | 'aToken'\n  | 'aToken2'\n  | 'idleToken'\n  | 'Chai'\n  | 'bDAI';\n\nexport type TokenType = 'ETH' | 'ERC20' | 'SYNTH';\n\n/**\n * @type Token object returned from API used internally in API\n */\n// consider if need the old class Token for backwards compatipility\n// otherwise no real need\nexport type Token = {\n  address: string;\n  decimals: number;\n  symbol?: string | undefined;\n  tokenType: LendingToken | TokenType;\n  mainConnector: string;\n  connectors: string[];\n  network: number;\n  img?: string | undefined;\n  allowance?: string | undefined;\n  balance?: string | undefined;\n};\n\ntype ConstructTokenInput = MarkOptional<\n  Token,\n  // these props are constructed from other, required props\n  'tokenType' | 'mainConnector' | 'connectors' | 'network'\n>;\n\nexport const constructToken = (tokenProps: ConstructTokenInput): Token => {\n  const {\n    tokenType = 'ERC20',\n    mainConnector = 'ETH',\n    connectors: connectorsInput = [],\n    network = 1,\n    ...rest\n  } = tokenProps;\n\n  const connectors: Token['connectors'] =\n    connectorsInput.length > 0 ? connectorsInput : [mainConnector];\n\n  return {\n    tokenType,\n    connectors,\n    mainConnector,\n    network,\n    ...rest,\n  };\n};\n","import { API_URL } from '../../constants';\nimport {\n  Token,\n  Address,\n  constructToken,\n  AddressOrSymbol,\n} from '../../helpers/token';\nimport type {\n  ConstructFetchInput,\n  TokenApiResponse,\n  TokensApiResponse,\n  RequestParameters,\n} from '../../types';\n\ntype GetBalances = (\n  userAddress: Address,\n  requestParams?: RequestParameters\n) => Promise<Token[]>;\ntype GetBalance = (\n  userAddress: Address,\n  tokenAddressOrSymbol: AddressOrSymbol,\n  requestParams?: RequestParameters\n) => Promise<Token | typeof NOT_FOUND_RESPONSE>;\n\nexport interface Allowance {\n  tokenAddress: Address;\n  allowance: string;\n}\n\ntype GetAllowances = (\n  userAddress: Address,\n  tokenAddresses: Address[],\n  requestParams?: RequestParameters\n) => Promise<Allowance[]>;\ntype GetAllowance = (\n  userAddress: Address,\n  tokenAddress: Address,\n  requestParams?: RequestParameters\n) => Promise<Allowance | typeof NOT_FOUND_RESPONSE>;\n\nexport const isAllowance = (\n  arg: Awaited<ReturnType<GetAllowance>>\n): arg is Allowance => {\n  return 'allowance' in arg;\n};\n\nexport type GetBalancesFunctions = {\n  getBalance: GetBalance;\n  getBalances: GetBalances;\n  getAllowance: GetAllowance;\n  getAllowances: GetAllowances;\n};\n\nconst NOT_FOUND_RESPONSE = { message: 'Not Found' } as const;\n\nexport const constructGetBalances = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetBalancesFunctions => {\n  const tokensUrl = `${apiURL}/users/tokens/${chainId}` as const;\n\n  const getBalances: GetBalances = async (userAddress, requestParams) => {\n    const fetchURL = `${tokensUrl}/${userAddress}` as const;\n\n    const data = await fetcher<TokensApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    const tokens = data.tokens.map(constructToken);\n\n    return tokens;\n  };\n\n  const getBalance: GetBalance = async (\n    userAddress,\n    tokenAddressOrSymbol,\n    requestParams\n  ) => {\n    const fetchURL =\n      `${tokensUrl}/${userAddress}/${tokenAddressOrSymbol}` as const;\n\n    const data = await fetcher<TokenApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    if (!data.token) {\n      return NOT_FOUND_RESPONSE;\n    }\n\n    return constructToken(data.token);\n  };\n\n  const getAllowances: GetAllowances = async (\n    userAddress,\n    tokenAddresses,\n    requestParams\n  ) => {\n    const tokenAddressesLowercaseSet = new Set(\n      tokenAddresses.map((address) => address.toLowerCase())\n    );\n\n    const balances = await getBalances(userAddress, requestParams);\n\n    const allowances: Allowance[] = balances\n      .filter((token) =>\n        tokenAddressesLowercaseSet.has(token.address.toLowerCase())\n      )\n      .map(({ address, allowance = '0' }) => ({\n        tokenAddress: address,\n        allowance,\n      }));\n\n    return allowances;\n  };\n\n  const getAllowance: GetAllowance = async (\n    userAddress,\n    tokenAddress,\n    requestParams\n  ) => {\n    const balanceOrNotFound = await getBalance(\n      userAddress,\n      tokenAddress,\n      requestParams\n    );\n\n    if ('message' in balanceOrNotFound) {\n      return balanceOrNotFound;\n    }\n\n    const { address, allowance = '0' } = balanceOrNotFound;\n\n    return { tokenAddress: address, allowance };\n  };\n\n  return {\n    getBalance,\n    getBalances,\n    getAllowance,\n    getAllowances,\n  };\n};\n","import type {\n  ConstructFetchInput,\n  ParaSwapVersionUnion,\n  RequestParameters,\n} from '../../types';\nimport { constructSearchString } from '../../helpers/misc';\nimport { API_URL, DEFAULT_VERSION } from '../../constants';\n\ntype AdaptersAsStrings = string[];\n\nexport type GetAdaptersFunctions = {\n  getAdapters: (\n    requestParams?: RequestParameters\n  ) => Promise<AdaptersAsStrings>;\n};\n\ntype SearchStringParams = {\n  network: number;\n  version?: ParaSwapVersionUnion;\n};\n\nexport const constructGetAdapters = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetAdaptersFunctions => {\n  const getAdapters: GetAdaptersFunctions['getAdapters'] = async (\n    requestParams\n  ): Promise<AdaptersAsStrings> => {\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const query = constructSearchString<SearchStringParams>({\n      network: chainId,\n      version,\n    });\n\n    const fetchURL = `${apiURL}/adapters/list${query}` as const;\n\n    const data = await fetcher<AdaptersAsStrings>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data;\n  };\n\n  return { getAdapters };\n};\n","import type { PickKeys } from 'ts-essentials';\nimport type { RateOptions } from '../rates';\n\ntype StringArrKeys = PickKeys<RateOptions, string[] | undefined>;\n\ntype MinRateOptionsInput = Pick<RateOptions, StringArrKeys> &\n  Pick<RateOptions, 'partner'>;\n\ntype NormalizedRateOptions<\n  O extends MinRateOptionsInput,\n  T extends { options?: Partial<O> }\n> = Partial<Record<StringArrKeys | 'partner', string>> &\n  Partial<Omit<O, StringArrKeys | 'partner'>> &\n  Omit<T, 'options'>;\n\nexport function normalizeRateOptions<\n  O extends MinRateOptionsInput,\n  T extends { options?: Partial<O> }\n>({ options = {}, ...restInput }: T): NormalizedRateOptions<O, T> {\n  const {\n    excludePricingMethods,\n    excludeContractMethods,\n    includeContractMethods,\n    partner,\n    includeDEXS,\n    excludeDEXS,\n    excludePools,\n    ...restOptions\n  } = options;\n\n  const [\n    _includeDEXS,\n    _excludeDEXS,\n    _excludePools,\n    _excludePricingMethods,\n    _excludeContractMethods,\n    _includeContractMethods,\n  ] = [\n    includeDEXS,\n    excludeDEXS,\n    excludePools,\n    excludePricingMethods,\n    excludeContractMethods,\n    includeContractMethods,\n    //                                                                                              no \"\" empty string\n  ].map((array) => array?.join(',') || undefined);\n\n  const transformed: Partial<Record<StringArrKeys | 'partner', string>> = {\n    excludePricingMethods: _excludePricingMethods,\n    excludeContractMethods: _excludeContractMethods,\n    includeContractMethods: _includeContractMethods,\n    partner,\n    includeDEXS: _includeDEXS,\n    excludeDEXS: _excludeDEXS,\n    excludePools: _excludePools,\n  };\n\n  return { ...transformed, ...restOptions, ...restInput };\n}\n","import {\n  API_URL,\n  DEFAULT_VERSION,\n  ContractMethodByName,\n} from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  ConstructFetchInput,\n  PriceRouteApiResponse,\n  Address,\n  AddressOrSymbol,\n  PriceString,\n  OptimalRate,\n  RequestParameters,\n  EnumerateLiteral,\n} from '../../types';\nimport { normalizeRateOptions } from './helpers/normalizeRateOptions';\n\n// TODO: This is legacy and can be removed\nexport enum PricingMethod {\n  megapath = 'megapath',\n  multipath = 'multipath',\n  simplepath = 'simplepath',\n}\n\ntype PricingMethodByName = EnumerateLiteral<typeof PricingMethod>;\n\ntype RateQueryParams = {\n  /**\n   * @description Source Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  srcToken: string;\n\n  /**\n   * @description Source Token Decimals. (Can be omitted if Token Symbol is used in `srcToken`).\n   */\n  srcDecimals?: number;\n\n  /**\n   * @description Destination Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  destToken: string;\n\n  /**\n   * @description srcToken amount (in case of SELL) or destToken amount (in case of BUY). The amount should be in **WEI/Raw units** (eg. 1WBTC -> 100000000).\n   */\n  amount: string;\n\n  /**\n   * @description **SELL** or **BUY**. Default: `SELL`.\n   */\n  side?: 'SELL' | 'BUY';\n\n  /**\n   * @description Network ID. (Mainnet - 1, Optimism - 10, BSC - 56, Polygon - 137, Fantom - 250, zkEVM - 1101, Base - 8453, Arbitrum - 42161, Avalanche - 43114). Default: `1`.\n   */\n  network?: number;\n\n  /**\n   * @description If provided, **others** object is filled in the response with price quotes from other exchanges _(if available for comparison)_. Default: `false`.\n   */\n  otherExchangePrices?: boolean;\n\n  /**\n   * @description Comma Separated List of DEXs to include. **Supported DEXs:** UniswapV2, UniswapV3, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, Balancer, MakerDAO, Chai, Aave, Aave2 and more. You can view all currently supported dexes filtered by chain [here](https://api.paraswap.io/adapters/list/1) eg: `UniswapV3,MakerDAO`.\n   */\n  includeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to include in pricing (without spaces). View the list of the supported methods for [V5](https://developers.paraswap.network/api/master/api-v5#supported-methods) and [V6](https://developers.paraswap.network/api/master/api-v6.2#supported-methods) eg: `swapExactAmountIn,swapExactAmountInOnUniswapV2`.\n   */\n  includeContractMethods?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to exclude from pricing (without spaces). View the list of the supported methods for [V5](https://developers.paraswap.network/api/master/api-v5#supported-methods) and [V6](https://developers.paraswap.network/api/master/api-v6.2#supported-methods).\n   */\n  excludeContractMethods?: string;\n\n  /**\n   * @description User's Wallet Address.\n   */\n  userAddress?: string;\n\n  /**\n   * @description Dash (-) separated list of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string;\n\n  /**\n   * @description Partner string.\n   */\n  partner?: string;\n\n  /**\n   * @description Destination Token Decimals. (Can be omitted if Token Symbol is used in `destToken`).\n   */\n  destDecimals?: number;\n\n  /**\n   * @description In %. It's a way to bypass the API price impact check (default = 15%).\n   */\n  maxImpact?: number;\n\n  /**\n   * @description Receiver's Wallet address. (Can be omitted if swapping tokens from and to same account).\n   */\n  receiver?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  srcTokenTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  destTokenTransferFee?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.\n   */\n  srcTokenDexTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs, not on ordinary transfers.\n   */\n  destTokenDexTransferFee?: string;\n\n  /**\n   * @description To specify the protocol version. **Values:** 5 or 6.2 **Default**: 5.\n   */\n  version?: number | string;\n\n  /**\n   * @description Specify that methods without fee support should be excluded from the price route. Default: `false`.\n   */\n  excludeContractMethodsWithoutFeeModel?: boolean;\n\n  /**\n   * @description If tokens USD prices are not available, `Bad USD Price` error will be thrown. Use this param to skip this check. Default: `false`.\n   */\n  ignoreBadUsdPrice?: boolean;\n  /**\n   * @description \tExclude all RFQs from pricing, e.g.: AugustusRFQ, Hashflow. Default: false\n   */\n  excludeRFQ?: boolean;\n};\n\n// more details in the docs https://developers.paraswap.network/api/get-rate-for-a-token-pair#query-parameters\nexport type RateOptions = {\n  excludeDEXS?: string[];\n  includeDEXS?: string[];\n  excludePools?: string[];\n  excludePricingMethods?: PricingMethodByName[];\n  excludeContractMethods?: ContractMethodByName[];\n  includeContractMethods?: ContractMethodByName[];\n  partner?: string;\n  /** @description In %. It's a way to bypass the API price impact check (default = 15%) */\n  maxImpact?: number;\n  maxUSDImpact?: number;\n  otherExchangePrices?: boolean;\n  /** @description proceed with priceRoute building even when tokens don't have USD price. Default: false */\n  ignoreBadUsdPrice?: boolean;\n  /** @description Exclude all RFQs from pricing, e.g.: AugustusRFQ, Hashflow. Default: false */\n  excludeRFQ?: boolean;\n  /** @description \tSpecify that methods without fee support should be excluded from the price route. Default: false */\n  excludeContractMethodsWithoutFeeModel?: boolean;\n  /** @description If the source token is a tax token, you should specify the tax amount in BPS.  */\n  srcTokenTransferFee?: string;\n  /** @description If the destination token is a tax token, you should specify the tax amount in BPS.  */\n  destTokenTransferFee?: string;\n  /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */\n  srcTokenDexTransferFee?: string;\n  /** @description Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.  */\n  destTokenDexTransferFee?: string;\n};\n\ntype CommonGetRateInput = {\n  amount: PriceString;\n  userAddress?: Address;\n  side?: 'SELL' | 'BUY';\n  options?: RateOptions;\n  srcDecimals?: number;\n  destDecimals?: number;\n};\n\nexport type GetRateInput = CommonGetRateInput & {\n  srcToken: AddressOrSymbol;\n  destToken: AddressOrSymbol;\n};\n\nexport type GetRate = (\n  options: GetRateInput,\n  requestParams?: RequestParameters\n) => Promise<OptimalRate>;\n\ntype GetRateByRouteInput = CommonGetRateInput & {\n  route: AddressOrSymbol[];\n};\n\ntype GetRateByRoute = (\n  options: GetRateByRouteInput,\n  requestParams?: RequestParameters\n) => Promise<OptimalRate>;\n\nexport type GetRateFunctions = {\n  getRate: GetRate;\n  getRateByRoute: GetRateByRoute;\n};\nconst INVALID_ROUTE = 'Invalid Route';\n\nexport const constructGetRate = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetRateFunctions => {\n  const pricesUrl = `${apiURL}/prices` as const;\n\n  const getRate: GetRate = async (\n    { srcToken, destToken, ...rest },\n    requestParams\n  ) => {\n    const parsedOptions = normalizeRateOptions(rest);\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<Omit<RateQueryParams, 'route'>>({\n      srcToken,\n      destToken,\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<PriceRouteApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data.priceRoute;\n  };\n\n  const getRateByRoute: GetRateByRoute = async (\n    { route, ...rest },\n    requestParams\n  ) => {\n    if (route.length < 2) {\n      throw new Error(INVALID_ROUTE);\n    }\n\n    const parsedOptions = normalizeRateOptions(rest);\n\n    const _route = route.join('-');\n\n    const search = constructSearchString<\n      Omit<RateQueryParams, 'srcToken' | 'destToken'>\n    >({\n      route: _route, // route can be used in place of srcToken+destToken\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<PriceRouteApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data.priceRoute;\n  };\n\n  return {\n    getRate,\n    getRateByRoute,\n  };\n};\n","import {\n  API_URL,\n  DEFAULT_VERSION,\n  ContractMethodByName,\n} from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  ConstructFetchInput,\n  RequestParameters,\n  SwapApiResponse,\n} from '../../types';\nimport { normalizeRateOptions } from './helpers/normalizeRateOptions';\n\n/**\n * Types for transaction parameters.\n */\ntype SwapQueryParams = {\n  /**\n   * @description Source Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  srcToken: string;\n\n  /**\n   * @description Source Token Decimals. (Can be omitted if Token Symbol is used in `srcToken`).\n   */\n  srcDecimals?: number;\n\n  /**\n   * @description Destination Token Address. Instead, **Token Symbol** could be used for tokens listed in the `/tokens` endpoint.\n   */\n  destToken: string;\n\n  /**\n   * @description srcToken amount (in case of SELL) or destToken amount (in case of BUY). The amount should be in **WEI/Raw units** (eg. 1WBTC -> 100000000).\n   */\n  amount: string;\n\n  /**\n   * @description **SELL** or **BUY**. Default: `SELL`.\n   */\n  side: 'SELL' | 'BUY';\n\n  /**\n   * @description Network ID. (Mainnet - 1, Optimism - 10, BSC - 56, Polygon - 137, Fantom - 250, zkEVM - 1101, Base - 8453, Arbitrum - 42161, Avalanche - 43114). Default: `1`.\n   */\n  network?: number;\n\n  /**\n   * @description Comma Separated List of DEXs to include. **Supported DEXs:** Uniswap, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, 0x, MakerDAO, Chai, Aave, Aave2, MultiPath, MegaPath, Curve, Curve3, Saddle, IronV2, BDai, idle, Weth, Beth, UniswapV2, Balancer, 0xRFQt, SushiSwap, LINKSWAP, Synthetix, DefiSwap, Swerve, CoFiX, Shell, DODOV1, DODOV2, OnChainPricing, PancakeSwap, PancakeSwapV2, ApeSwap, Wbnb, acryptos, streetswap, bakeryswap, julswap, vswap, vpegswap, beltfi, ellipsis, QuickSwap, COMETH, Wmatic, Nerve, Dfyn, UniswapV3, Smoothy, PantherSwap, OMM1, OneInchLP, CurveV2, mStable, WaultFinance, MDEX, ShibaSwap, CoinSwap, SakeSwap, JetSwap, Biswap, BProtocol eg: `UniswapV3,0x`.\n   */\n  includeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to include without spaces. **Available values:** swapOnUniswap, buyOnUniswap, swapOnUniswapFork, buyOnUniswapFork, swapOnUniswapV2Fork, buyOnUniswapV2Fork, simpleBuy, simpleSwap, multiSwap, megaSwap, protectedMultiSwap, protectedMegaSwap, protectedSimpleSwap, protectedSimpleBuy, swapOnZeroXv2, swapOnZeroXv4, buy. eg: `simpleSwap,multiSwap`.\n   */\n  includeContractMethods?: string;\n\n  /**\n   * @description Comma Separated List of Contract Methods to exclude without spaces. (from the list of contract methods mentioned above).\n   */\n  excludeContractMethods?: string;\n\n  /**\n   * @description User's Wallet Address.\n   */\n  userAddress: string;\n\n  /**\n   * @description Dash (-) separated list of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string;\n\n  /**\n   * @description Partner string.\n   */\n  partner?: string;\n\n  /**\n   * @description If provided it is used together with `partnerAddress`. Should be in basis points percentage. Look at `slippage` parameter description for understanding better. Eg: `200` (for 2% fee percent). Fees have to be claimed from the Fee Claimer contract unless `_isSurplusToUser_` or `_isDirectFeeTransfer_` are used.\n   */\n  partnerFeeBps?: string;\n\n  /**\n   * @description Address that will be entitled to claim fees or surplus. Fees have to be claimed from the Fee Claimer contract unless `_isSurplusToUser_` or `_isDirectFeeTransfer_` are used.\n   */\n  partnerAddress?: string;\n\n  /**\n   * @description Allowed slippage percentage represented in basis points. _Eg:_ for **2.5%** slippage, set the value to **2.5 \\* 100 = 250**; for 10% = 1000.\n   */\n  slippage: number;\n\n  /**\n   * @description Destination Token Decimals. (Can be omitted if Token Symbol is used in `destToken`).\n   */\n  destDecimals?: number;\n\n  /**\n   * @description In %. It's a way to bypass the API price impact check (default = 15%).\n   */\n  maxImpact?: number;\n\n  /**\n   * @description Receiver's Wallet address. (Can be omitted if swapping tokens from and to same account).\n   */\n  receiver?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  srcTokenTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. For example: for a token with a 5% tax, you should set it to 500 as `[(500/10000)*100=5%]`. Note: not all DEXs and contract methods support trading tax tokens, so we will filter those that don't.\n   */\n  destTokenTransferFee?: string;\n\n  /**\n   * @description If the source token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs and not on ordinary transfers.\n   */\n  srcTokenDexTransferFee?: string;\n\n  /**\n   * @description If the destination token is a tax token, you should specify the tax amount in BPS. Some tokens only charge tax when swapped in/out DEXs, not on ordinary transfers.\n   */\n  destTokenDexTransferFee?: string;\n\n  /**\n   * @description To specify the protocol version. **Values:** 5 or 6.2 **Default**: 5.\n   */\n  version?: number | string;\n\n  /**\n   * @description If tokens USD prices are not available, `Bad USD Price` error will be thrown. Use this param to skip this check. Default: `false`.\n   */\n  ignoreBadUsdPrice?: boolean;\n\n  /**\n   * @description Specify if user should receive surplus instead of partner. Default: `false`.\n   */\n  isSurplusToUser?: boolean;\n\n  /**\n   * @description Specify if fees should be sent directly to the partner instead of registering them on FeeClaimer. Default: `false`.\n   */\n  isDirectFeeTransfer?: boolean;\n\n  /**\n   * @description Allows for capping the surplus at 1% maximum. Default: `true`.\n   */\n  isCapSurplus?: boolean;\n\n  /**\n   * @description Allows to collect surplus. Works with `partnerAddress`. Default: `false`.\n   */\n  takeSurplus?: boolean;\n};\n\ntype SwapTxInputFields =\n  | 'srcToken'\n  | 'destToken'\n  | 'amount'\n  | 'side'\n  | 'srcDecimals'\n  | 'destDecimals'\n  | 'userAddress'\n  | 'slippage';\ntype SwapTxInputListFields =\n  | 'includeDEXS'\n  | 'excludeDEXS'\n  | 'includeContractMethods'\n  | 'excludeContractMethods'\n  | 'route';\n\ntype SwapRateOptions = Omit<\n  SwapQueryParams,\n  SwapTxInputFields | SwapTxInputListFields | 'network' | 'version'\n> & {\n  /**\n   * @description List of DEXs to include. **Supported DEXs:** Uniswap, Kyber, Bancor, AugustusRFQ, Oasis, Compound, Fulcrum, 0x, MakerDAO, Chai, Aave, Aave2, MultiPath, MegaPath, Curve, Curve3, Saddle, IronV2, BDai, idle, Weth, Beth, UniswapV2, Balancer, 0xRFQt, SushiSwap, LINKSWAP, Synthetix, DefiSwap, Swerve, CoFiX, Shell, DODOV1, DODOV2, OnChainPricing, PancakeSwap, PancakeSwapV2, ApeSwap, Wbnb, acryptos, streetswap, bakeryswap, julswap, vswap, vpegswap, beltfi, ellipsis, QuickSwap, COMETH, Wmatic, Nerve, Dfyn, UniswapV3, Smoothy, PantherSwap, OMM1, OneInchLP, CurveV2, mStable, WaultFinance, MDEX, ShibaSwap, CoinSwap, SakeSwap, JetSwap, Biswap, BProtocol eg: `UniswapV3,0x`.\n   */\n  includeDEXS?: string[];\n\n  /**\n   * @description List of DEXs to exclude. (from the list of DEXs mentioned above).\n   */\n  excludeDEXS?: string[];\n\n  /**\n   * @description List of Contract Methods to include without spaces. **Available values:** swapOnUniswap, buyOnUniswap, swapOnUniswapFork, buyOnUniswapFork, swapOnUniswapV2Fork, buyOnUniswapV2Fork, simpleBuy, simpleSwap, multiSwap, megaSwap, protectedMultiSwap, protectedMegaSwap, protectedSimpleSwap, protectedSimpleBuy, swapOnZeroXv2, swapOnZeroXv4, buy. eg: `simpleSwap,multiSwap`.\n   */\n  includeContractMethods?: ContractMethodByName[];\n\n  /**\n   * @description List of Contract Methods to exclude without spaces. (from the list of contract methods mentioned above).\n   */\n  excludeContractMethods?: ContractMethodByName[];\n};\n\ntype SwapTxInput = Pick<SwapQueryParams, SwapTxInputFields> & {\n  /**\n   * @description List of tokens (addresses or symbols from `/tokens`) to comprise the price route. _Max 4 tokens._ _**\\*Note:**_ _If_ `_route_` _is specified, the response will only comprise of the route specified which might not be the optimal route._\n   */\n  route?: string[];\n\n  options?: SwapRateOptions;\n};\n\nexport type SwapTxResult = SwapApiResponse;\n\nexport type GetSwapTxData = (\n  options: SwapTxInput,\n  requestParams?: RequestParameters\n) => Promise<SwapTxResult>;\n\nexport type GetSwapTxFunctions = {\n  getSwapTxData: GetSwapTxData;\n};\n\nexport const constructSwapTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetSwapTxFunctions => {\n  const pricesUrl = `${apiURL}/swap` as const;\n\n  const getSwapTxData: GetSwapTxData = async (\n    { srcToken, destToken, amount, route, ...rest },\n    requestParams\n  ) => {\n    const parsedOptions = normalizeRateOptions(rest);\n\n    const _route = route?.join('-');\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<SwapQueryParams>({\n      amount,\n      srcToken,\n      destToken,\n      route: _route,\n      network: chainId,\n      version,\n      ...parsedOptions,\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<SwapApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data;\n  };\n\n  return {\n    getSwapTxData,\n  };\n};\n","import { API_URL } from '../../constants';\nimport { constructToken } from '../../helpers/token';\nimport type {\n  RequestParameters,\n  ConstructFetchInput,\n  Token,\n  TokensApiResponse,\n} from '../../types';\n\ntype GetTokens = (extra?: RequestParameters) => Promise<Token[]>;\n\nexport type GetTokensFunctions = {\n  getTokens: GetTokens;\n};\n\nexport const constructGetTokens = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetTokensFunctions => {\n  const fetchURL = `${apiURL}/tokens/${chainId}` as const;\n\n  const getTokens: GetTokens = async (requestParams) => {\n    const data = await fetcher<TokensApiResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    const tokens = data.tokens.map(constructToken);\n    return tokens;\n  };\n\n  return { getTokens };\n};\n","export const name = 'AUGUSTUS RFQ';\nexport const version = '1';\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\n\ntype TypedDataDomain = {\n  name?: string;\n  version?: string;\n  chainId?: bigint | string | number;\n  verifyingContract?: string;\n  salt?: string;\n};\n\nexport type TypedDataField = {\n  name: string;\n  type: string;\n};\n\nexport type SignableTypedData = {\n  types: Record<string, TypedDataField[]>;\n  domain: TypedDataDomain;\n  data: Record<string, any>;\n};\n\nexport type Domain = {\n  name: string;\n  version: string;\n  chainId: number;\n  verifyingContract: string;\n};\n","import type { LimitOrderFromApi } from '../../limitOrders/helpers/types';\nimport { ZERO_ADDRESS } from './buildOrderData';\nimport type { OrderType } from './types';\n\ntype GetBaseFetchUrlInput = {\n  apiURL: string;\n  chainId: number;\n};\n\nexport type BaseFetchUrlInputConstructor<Kind extends OrderKind> = (\n  params: GetBaseFetchUrlInput\n) => UrlByTypeFunction<Kind>;\n\ntype OrderType2URLPart = {\n  LIMIT: 'orders';\n  P2P: 'p2p';\n};\n\ntype OrderKind = 'nft' | 'ft';\n\nexport type BaseFetchUrl<\n  Kind extends OrderKind,\n  Type extends OrderType = OrderType\n> = `${string}/${Kind}/${OrderType2URLPart[Type]}/${number}`;\n\nexport type MinFetchUrl<Kind extends OrderKind> = `${string}/${Kind}/order`;\nexport type OrderFillableBalanceFetchUrl<Kind extends OrderKind> =\n  `${string}/${Kind}/fillablebalance/${number}`;\n\ninterface UrlByTypeFunction<Kind extends OrderKind> {\n  (): MinFetchUrl<Kind>;\n  (type: 'LIMIT'): BaseFetchUrl<Kind, 'LIMIT'>;\n  (type: 'P2P'): BaseFetchUrl<Kind, 'P2P'>;\n  (type: OrderType): BaseFetchUrl<Kind>;\n  (type: 'fillablebalance'): OrderFillableBalanceFetchUrl<Kind>;\n  (type?: OrderType | 'fillablebalance'):\n    | BaseFetchUrl<Kind>\n    | MinFetchUrl<Kind>\n    | OrderFillableBalanceFetchUrl<Kind>;\n}\n\nexport function baseFetchUrlGetterFactory<Kind extends OrderKind>(\n  orderKind: Kind\n): BaseFetchUrlInputConstructor<Kind> {\n  return function constructBaseFetchUrlGetter({\n    chainId,\n    apiURL,\n  }: GetBaseFetchUrlInput): UrlByTypeFunction<Kind> {\n    function urlGetter(type: 'LIMIT'): BaseFetchUrl<Kind, 'LIMIT'>;\n    function urlGetter(type: 'P2P'): BaseFetchUrl<Kind, 'P2P'>;\n    function urlGetter(type: OrderType): BaseFetchUrl<Kind>;\n    function urlGetter(\n      type: 'fillablebalance'\n    ): OrderFillableBalanceFetchUrl<Kind>;\n    function urlGetter(): MinFetchUrl<Kind>;\n    function urlGetter(\n      type?: OrderType | 'fillablebalance'\n    ):\n      | BaseFetchUrl<Kind>\n      | MinFetchUrl<Kind>\n      | OrderFillableBalanceFetchUrl<Kind> {\n      if (!type) return `${apiURL}/${orderKind}/order` as const;\n\n      if (type === 'fillablebalance')\n        return `${apiURL}/${orderKind}/fillablebalance/${chainId}` as const;\n\n      const orderURLpart = type === 'LIMIT' ? 'orders' : 'p2p';\n      return `${apiURL}/${orderKind}/${orderURLpart}/${chainId}` as const;\n    }\n\n    return urlGetter;\n  };\n}\n\n// orders with taker = EOA address\n// that can't be filled through AugustusSwapper,\n// only through AugustusRFQ\nexport function isOrderFillableDirectlyOnRFQOnly(\n  order: Pick<LimitOrderFromApi, 'taker' | 'takerFromMeta'>\n): boolean {\n  // with 0x taker fillable by anyone\n  if (order.taker === ZERO_ADDRESS) return false;\n\n  // same intended EOA taker and msg.sender taker\n  return order.taker.toLowerCase() === order.takerFromMeta.toLowerCase();\n}\n","import {\n  BaseFetchUrl,\n  baseFetchUrlGetterFactory,\n  BaseFetchUrlInputConstructor,\n  MinFetchUrl,\n  OrderFillableBalanceFetchUrl,\n} from '../../common/orders/misc';\nimport type { OrderData } from './buildOrderData';\n\nexport function sanitizeOrderData({\n  nonceAndMeta,\n  expiry,\n  makerAsset,\n  takerAsset,\n  maker,\n  taker,\n  makerAmount,\n  takerAmount,\n}: OrderData & Record<string, any>): OrderData {\n  return {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n  };\n}\n\n/* \nGET\n/ft/orders/:chainId/maker/:walletAddress\n/ft/orders/:chainId/taker/:walletAddress\n/ft/p2p/:chainId/maker/:walletAddress\n/ft/p2p/:chainId/taker/:walletAddress\n*/\nexport type GetOrdersURLs = `${BaseFetchUrl<'ft'>}/${\n  | 'taker'\n  | 'maker'}/${string}`;\n\n/*\nGET\n/ft/fillablebalance/:chainId/:walletAddress/:makerAsset?\n*/\nexport type GetRequiredAllowanceURL =\n  `${OrderFillableBalanceFetchUrl<'ft'>}/${string}${`/${string}` | ''}`;\n\n/*\nGET\n/ft/order/:orderHash (get you p2p or orders)\n*/\nexport type GetOrderURL = `${MinFetchUrl<'ft'>}/${string}`;\n\n/* \nPOST create order\n/ft/orders/:chainId/\n/ft/p2p/:chainId/\n*/\nexport type PostOrderURLs = BaseFetchUrl<'ft'>;\n\nexport const constructBaseFetchUrlGetter: BaseFetchUrlInputConstructor<'ft'> =\n  baseFetchUrlGetterFactory('ft');\n","import type { Address } from '../../../types';\nimport type { AssetTypeVariant } from './types';\nimport {\n  Domain,\n  name,\n  version,\n  ZERO_ADDRESS,\n} from '../../common/orders/buildOrderData';\nimport { getRandomInt } from '../../../helpers/misc';\n\nconst OrderNFT = [\n  { name: 'nonceAndMeta', type: 'uint256' },\n  { name: 'expiry', type: 'uint128' },\n  { name: 'makerAsset', type: 'uint256' },\n  { name: 'makerAssetId', type: 'uint256' },\n  { name: 'takerAsset', type: 'uint256' },\n  { name: 'takerAssetId', type: 'uint256' },\n  { name: 'maker', type: 'address' },\n  { name: 'taker', type: 'address' },\n  { name: 'makerAmount', type: 'uint256' },\n  { name: 'takerAmount', type: 'uint256' },\n];\n\nexport interface BuildNFTOrderDataInput {\n  chainId: number;\n  verifyingContract: Address;\n  nonce?: number;\n  expiry: number;\n  makerAsset: Address;\n  takerAsset: Address;\n  makerAmount: string;\n  takerAmount: string;\n  /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */\n  makerAssetId: string; // required when BUYing NFT\n  /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */\n  takerAssetId?: string;\n  /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */\n  makerAssetType: AssetTypeVariant;\n  /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */\n  takerAssetType: AssetTypeVariant;\n  maker: Address;\n  // OrderData.taker must be Augustus for p2p limitOrders to involve swap through Augustus\n  // this is the actual user taker which will go into nonceAndMeta\n  taker?: Address;\n  AugustusAddress: Address;\n}\n\nexport type SignableNFTOrderData = {\n  types: { OrderNFT: typeof OrderNFT };\n  domain: Domain;\n  data: NFTOrderData;\n};\n\nexport type BigIntAsString = string;\n\nexport type NFTOrderData = {\n  expiry: number;\n  // '1' when trading 1 NFT token\n  makerAmount: BigIntAsString;\n  makerAsset: BigIntAsString;\n  // '0' indicates ERC20\n  makerAssetId: BigIntAsString;\n  // '1' when trading 1 NFT token\n  takerAmount: BigIntAsString;\n  takerAsset: BigIntAsString;\n  // '0' indicates ERC20\n  takerAssetId: BigIntAsString;\n  nonceAndMeta: BigIntAsString;\n  maker: Address;\n  taker: Address;\n};\n\nexport function buildOrderData({\n  chainId,\n  verifyingContract,\n  nonce = getRandomInt(),\n  expiry,\n  makerAsset: _makerAssetAddress,\n  takerAsset: _takerAssetAddress,\n  makerAmount,\n  takerAmount,\n  makerAssetId,\n  takerAssetId = '0',\n  makerAssetType,\n  takerAssetType,\n  maker,\n  AugustusAddress,\n  // if taker is specified -- p2p order for that taker only to fill through Augustus -- taker = Augustus, takerInNonce = _taker\n  // if taker is not specified -- limitOrder for anyone to fill through Augustus -- taker = Augustus, takerInNonce = Zero\n  taker: takerInNonce = ZERO_ADDRESS, //@TODO allow Orders outside of AugustusRFQ\n}: BuildNFTOrderDataInput): SignableNFTOrderData {\n  // first 160 bits is taker address (for p2p orders),\n  // or 0 for limitOrders, so that anyone can be the taker of the Order\n  const nonceAndMeta = (\n    BigInt(takerInNonce) +\n    (BigInt(nonce) << BigInt(160))\n  ).toString(10);\n\n  const makerAsset = assetAddressToUint(_makerAssetAddress, makerAssetType);\n\n  const takerAsset = assetAddressToUint(_takerAssetAddress, takerAssetType);\n\n  const orderNFT: NFTOrderData = {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker: AugustusAddress,\n    makerAmount,\n    takerAmount,\n    makerAssetId,\n    takerAssetId,\n  };\n\n  return {\n    types: { OrderNFT },\n    domain: { name, version, chainId, verifyingContract },\n    data: orderNFT,\n  };\n}\n\n// create a packed number that contains assetAddress and AssetType\nexport function assetAddressToUint(\n  assetAddress: Address,\n  assetType: AssetTypeVariant\n): BigIntAsString {\n  return (BigInt(assetAddress) + (BigInt(assetType) << BigInt(160))).toString(\n    10\n  );\n}\n","import {\n  BaseFetchUrl,\n  baseFetchUrlGetterFactory,\n  BaseFetchUrlInputConstructor,\n  MinFetchUrl,\n} from '../../common/orders/misc';\nimport {\n  assetAddressToUint,\n  BuildNFTOrderDataInput,\n  NFTOrderData,\n} from './buildOrderData';\n\n// any number can be assigned to AssetType enum\n// https://github.com/Microsoft/TypeScript/issues/22311\n// export enum AssetType {\n//   ERC20 = 0,\n//   ERC1155 = 1,\n//   ERC721 = 2,\n// }\n\nexport const AssetType = {\n  ERC20: 0,\n  ERC1155: 1,\n  ERC721: 2,\n} as const;\n\nexport function sanitizeOrderData({\n  nonceAndMeta,\n  expiry,\n  makerAsset: _makerAsset,\n  takerAsset: _takerAsset,\n  maker,\n  taker,\n  makerAmount,\n  takerAmount,\n  makerAssetId,\n  takerAssetId,\n  // asset types provided when Order has them ,e.g. got Order by hash from API\n  makerAssetType,\n  takerAssetType,\n}: NFTOrderData &\n  Partial<Pick<BuildNFTOrderDataInput, 'makerAssetType' | 'takerAssetType'>> &\n  Record<string, any>): NFTOrderData {\n  const makerAsset =\n    makerAssetType !== undefined && _makerAsset.startsWith('0x')\n      ? assetAddressToUint(_makerAsset, makerAssetType)\n      : _makerAsset;\n  const takerAsset =\n    takerAssetType !== undefined && _takerAsset.startsWith('0x')\n      ? assetAddressToUint(_takerAsset, takerAssetType)\n      : _takerAsset;\n\n  return {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n    makerAssetId,\n    takerAssetId,\n  };\n}\n\n/* \nGET\n/nft/orders/:chainId/maker/:walletAddress\n/nft/orders/:chainId/taker/:walletAddress\n/nft/p2p/:chainId/maker/:walletAddress\n/nft/p2p/:chainId/taker/:walletAddress\n*/\nexport type GetOrdersURLs = `${BaseFetchUrl<'nft'>}/${\n  | 'taker'\n  | 'maker'}/${string}`;\n\n/*\nGET\n/nft/order/:orderHash (get you p2p or orders)\n*/\nexport type GetOrderURL = `${MinFetchUrl<'nft'>}/${string}`;\n\n/* \nPOST create order\n/nft/orders/:chainId/\n/nft/p2p/:chainId/\n*/\nexport type PostOrderURLs = BaseFetchUrl<'nft'>;\n\nexport const constructBaseFetchUrlGetter: BaseFetchUrlInputConstructor<'nft'> =\n  baseFetchUrlGetterFactory('nft');\n","import type { WithGasPrice, WithMaxFee } from '../../gas';\nimport type {\n  ConstructFetchInput,\n  Address,\n  FetcherPostInput,\n  PriceString,\n  OptimalRate,\n  RequestParameters,\n} from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport { API_URL, SwapSide } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { OrderData } from '../limitOrders/buildOrder';\nimport { sanitizeOrderData as sanitizeLimitOrderData } from '../limitOrders/helpers/misc';\nimport { sanitizeOrderData as sanitizeNFTOrderData } from '../nftOrders/helpers/misc';\nimport { AssetTypeVariant } from '../nftOrders/helpers/types';\n\nexport interface TransactionParams {\n  to: string;\n  from: string;\n  value: string;\n  data: string;\n  gas?: string;\n  chainId: number;\n  // either gasPrice or maxFeePerGas & maxPriorityFeePerGas will be present\n  gasPrice?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n}\n\nexport type SwappableOrder = OrderData & {\n  permitMakerAsset?: string;\n  signature: string;\n};\n\nexport type SwappableNFTOrder = SwappableOrder & {\n  makerAssetId: string;\n  takerAssetId: string;\n  makerAssetType: AssetTypeVariant;\n  takerAssetType: AssetTypeVariant;\n};\n\n// when priceRoute with side=SELL, slippage can replace destAmount\nexport type TxInputAmountsPartSell = {\n  slippage: number;\n  srcAmount: PriceString;\n  destAmount?: never; // disallowed\n};\n// when priceRoute with side=BUY, slippage can replace srcAmount\nexport type TxInputAmountsPartBuy = {\n  slippage: number;\n  srcAmount?: never; // disallowed\n  destAmount: PriceString;\n};\n// both srcAmount and destAmount can be present in absence of slippage\nexport type TxInputAmountsPartBuyOrSell = {\n  slippage?: never; // disallowed\n  srcAmount: PriceString;\n  destAmount: PriceString;\n};\n\n// more details in the docs https://developers.paraswap.network/api/build-parameters-for-transaction#request-body\nexport type BuildTxInputBase = {\n  srcToken: Address;\n  destToken: Address;\n  userAddress: Address;\n  /** @description Whenever msg.sender (`userAddress`) i.e. address calling the ParaSwap contract is different than the address sending the transaction, `txOrigin` must be passed along with `userAddress` */\n  txOrigin?: string;\n  /** @description used with referral link */\n  referrer?: string;\n  partner?: string;\n  partnerAddress?: string;\n  partnerFeeBps?: number;\n  /** @description If user should receive surplus instead of partner. Default: false */\n  isSurplusToUser?: boolean;\n  /** @description If fees should be sent directly to the partner instead of registering them on FeeClaimer. v6 only. Default: false */\n  isDirectFeeTransfer?: boolean;\n  /** @deprecated Use \"takeSurplus\" instead. Positive slippage goes to user, true by default */\n  positiveSlippageToUser?: boolean;\n  /** @description Set to true to take positive slippage. Works with partnerAddress. Default: false */\n  takeSurplus?: boolean;\n  /** @description Cap the surplus at 1% maximum. Default: true */\n  isCapSurplus?: boolean;\n  receiver?: Address;\n  srcDecimals?: number;\n  destDecimals?: number;\n  permit?: string;\n  deadline?: string;\n};\n\n// for Swap transaction\nexport type BuildSwapTxInput = BuildTxInputBase & {\n  priceRoute: OptimalRate;\n} & (\n    | TxInputAmountsPartSell\n    | TxInputAmountsPartBuy\n    | TxInputAmountsPartBuyOrSell\n  ); // this union doesn't allow to mix srcAmount & destAmount & slippage together\n\n// building block for LimitOrders and NFT Orders swaps\n// can only use priceRoute.side=BUY and related TxInputAmountsPart*\ntype BuildTxInputBaseBUYForOrders<\n  // to Omit extra keys\n  // can't do Omit<> around union, breaks discriminated union\n  K extends keyof TxInputAmountsPartBuy | keyof BuildTxInputBase = never\n> = Omit<BuildTxInputBase, K> &\n  // destAmount is sum(orders[].makerAmount)\n  (| Omit<TxInputAmountsPartBuy, 'destAmount' | K>\n    | Omit<TxInputAmountsPartBuyOrSell, 'destAmount' | K>\n  );\n\n// for LimitOrder Fill, without swap\nexport type BuildLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {\n  orders: SwappableOrder[];\n  srcDecimals: number;\n  destDecimals: number;\n};\n\n// for NFT Order Fill, without swap\nexport type BuildNFTOrderTxInput =\n  // @TODO if NFT can ever be srcToken, change logic\n  //                           for NFT token destDecimals = 0 is acceptable\n  BuildTxInputBaseBUYForOrders<'destDecimals'> & {\n    orders: SwappableNFTOrder[];\n    srcDecimals: number;\n  };\n\nexport interface BuildSwapAndLimitOrderTxInput0\n  // destAmount is sum(orders[].makerAmount)\n  extends Omit<BuildTxInputBase, 'destAmount'> {\n  priceRoute: OptimalRate; // priceRoute.side=BUY\n  orders: SwappableOrder[];\n  destDecimals: number;\n}\n// for Swap + LimitOrder, priceRoute must have side=BUY\nexport type BuildSwapAndLimitOrderTxInput =\n  // destAmount is sum(orders[].makerAmount)\n  BuildTxInputBaseBUYForOrders & {\n    priceRoute: OptimalRate; // priceRoute.side=BUY & priceRoute.contractMethod=simpleBuy\n    orders: SwappableOrder[];\n    destDecimals: number;\n  };\n\n// with slippage for a swap and fill - p2p - order, without to fill a p2p order directly with the intended taker asset\n\n// for Swap + NFT Order, priceRoute must have side=BUY\nexport type BuildSwapAndNFTOrderTxInput =\n  // destAmount is sum(orders[].makerAmount)\n  BuildTxInputBaseBUYForOrders & {\n    priceRoute: OptimalRate; // priceRoute.side=BUY & priceRoute.contractMethod=simpleBuy\n    orders: SwappableNFTOrder[];\n  };\n\nexport type BuildTxInput =\n  | BuildSwapTxInput\n  | BuildLimitOrderTxInput\n  | BuildNFTOrderTxInput\n  | BuildSwapAndLimitOrderTxInput\n  | BuildSwapAndNFTOrderTxInput;\n\nexport type BuildOptionsBase = {\n  /** @description Allows the API to skip performing onchain checks such as balances, allowances, as well as transaction simulations. The response does not contain `gas` parameter when set to `true` */\n  ignoreChecks?: boolean;\n  /** @description Allows the API to skip gas checks. The response does not contain `gas` parameter when set to `true` */\n  ignoreGasEstimate?: boolean;\n  /** @description Allows the API to skip performing onchain allowance checks. */\n  ignoreAllowance?: boolean;\n  /** @description Allows the API to return the contract parameters only. */\n  onlyParams?: boolean;\n};\n\nexport type BuildOptionsWithGasPrice = BuildOptionsBase & Partial<WithGasPrice>;\nexport type BuildOptionsWitWithMaxFee = BuildOptionsBase & Partial<WithMaxFee>;\n\nexport type BuildOptions = BuildOptionsWithGasPrice | BuildOptionsWitWithMaxFee;\n\ntype BuildTx = (\n  params: BuildTxInput,\n  options?: BuildOptions,\n  requestParams?: RequestParameters\n) => Promise<TransactionParams>;\n\nexport type BuildTxFunctions = {\n  buildTx: BuildTx;\n};\n\ntype SearchStringParams = BuildOptions;\n\nexport const constructBuildTx = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildTxFunctions => {\n  const transactionsURL = `${apiURL}/transactions/${chainId}` as const;\n\n  const buildTx: BuildTx = async (params, options = {}, requestParams) => {\n    if (\n      'priceRoute' in params &&\n      'destAmount' in params && // isn't provided together with `orders`\n      !('orders' in params) // when present, destAmount becomes sum(orders[].makerAmount)\n    ) {\n      const {\n        priceRoute,\n        priceRoute: { side },\n      } = params;\n      const AmountMismatchError =\n        side === SwapSide.SELL\n          ? 'Source Amount Mismatch'\n          : 'Destination Amount Mismatch';\n\n      // user provides srcAmount or slippage but not both. so we only validate accordingly.\n      assert(\n        areAmountsCorrect({\n          queryParams: params,\n          side,\n          priceRoute,\n        }),\n        AmountMismatchError\n      );\n    }\n\n    // always pass explicit type to make sure UrlSearchParams are correct\n    const search = constructSearchString<SearchStringParams>(options);\n\n    const fetchURL = `${transactionsURL}/${search}` as const;\n\n    const sanitizedParams =\n      'orders' in params && params.orders.length > 0\n        ? {\n            ...params,\n            //  make sure we don't pass more with orders than API expects\n            orders: params.orders.map((order) => {\n              const sanitizedOrderData =\n                'makerAssetId' in order\n                  ? sanitizeNFTOrderData(order) // assetType is provided here, because Order.*Asset may be address\n                  : // if Order received from API by hash\n                    sanitizeLimitOrderData(order);\n\n              const sanitizedOrder: SwappableOrder = {\n                ...sanitizedOrderData,\n                signature: order.signature,\n              };\n\n              if (order.permitMakerAsset) {\n                sanitizedOrder.permitMakerAsset = order.permitMakerAsset;\n              }\n\n              return sanitizedOrder;\n            }),\n          }\n        : params;\n\n    const takeSurplus =\n      params.takeSurplus ??\n      (params.positiveSlippageToUser !== undefined\n        ? !params.positiveSlippageToUser\n        : undefined);\n\n    if ('positiveSlippageToUser' in sanitizedParams) {\n      // positiveSlippageToUser & takeSurplus together will Error in API\n      delete sanitizedParams.positiveSlippageToUser;\n    }\n    if (takeSurplus !== undefined) {\n      sanitizedParams.takeSurplus = takeSurplus;\n    }\n\n    const fetchParams: FetcherPostInput = {\n      url: fetchURL,\n      method: 'POST',\n      data: sanitizedParams,\n      requestParams,\n    };\n\n    const builtTx = await fetcher<TransactionParams>(fetchParams);\n\n    return builtTx;\n  };\n\n  return { buildTx };\n};\n\ninterface AreAmountsCorrectInput {\n  queryParams: { srcAmount?: string; destAmount?: string; slippage?: number };\n  side: SwapSide;\n  priceRoute: OptimalRate;\n}\n\nfunction areAmountsCorrect({\n  queryParams,\n  side,\n  priceRoute,\n}: AreAmountsCorrectInput): boolean {\n  // return early after a simpler check if the user was swapping before filling\n  if (queryParams.slippage) {\n    return (\n      (side === SwapSide.BUY &&\n        queryParams.destAmount === priceRoute.destAmount) ||\n      (side === SwapSide.SELL && queryParams.srcAmount === priceRoute.srcAmount)\n    );\n  }\n\n  // provided amounts match the previously queried price route\n  const [inputAmount, priceRouteAmount] =\n    side === SwapSide.SELL\n      ? [queryParams.srcAmount, priceRoute.srcAmount]\n      : [queryParams.destAmount, priceRoute.destAmount];\n\n  return inputAmount === priceRouteAmount;\n}\n","import { getRandomInt } from '../../../helpers/misc';\nimport type { Address, ParaSwapVersionUnion } from '../../../types';\nimport {\n  Domain,\n  name,\n  version,\n  ZERO_ADDRESS,\n} from '../../common/orders/buildOrderData';\n\nconst Order = [\n  { name: 'nonceAndMeta', type: 'uint256' },\n  { name: 'expiry', type: 'uint128' },\n  { name: 'makerAsset', type: 'address' },\n  { name: 'takerAsset', type: 'address' },\n  { name: 'maker', type: 'address' },\n  { name: 'taker', type: 'address' },\n  { name: 'makerAmount', type: 'uint256' },\n  { name: 'takerAmount', type: 'uint256' },\n];\n\nexport interface BuildOrderDataInput {\n  chainId: number;\n  verifyingContract: Address;\n  nonce?: number;\n  expiry: number;\n  makerAsset: Address;\n  takerAsset: Address;\n  makerAmount: string;\n  takerAmount: string;\n  maker: Address;\n  // OrderData.taker must be Augustus (or other Executor) for p2p limitOrders to involve swap through Augustus\n  /** @description actual user taker which will go into nonceAndMeta */\n  taker?: Address;\n  /** @description contract executor (Augustus or similar) that is allowed to execute the order, gois in Order.taker */\n  contractTaker?: Address;\n\n  AugustusAddress: Address;\n  AppVersion: ParaSwapVersionUnion;\n}\n\nexport type SignableOrderData = {\n  types: { Order: typeof Order };\n  domain: Domain;\n  data: OrderData;\n};\n\nexport type OrderData = {\n  nonceAndMeta: string;\n  expiry: number;\n  makerAsset: string;\n  takerAsset: string;\n  maker: string;\n  taker: string;\n  makerAmount: string;\n  takerAmount: string;\n};\n\nexport function buildOrderData({\n  chainId,\n  verifyingContract,\n  nonce = getRandomInt(),\n  expiry,\n  makerAsset,\n  takerAsset,\n  makerAmount,\n  takerAmount,\n  maker,\n  AugustusAddress,\n  // if taker is specified -- p2p order for that taker only to fill through Augustus (v5) or direcly (v6)-- taker = Augustus | _taker, takerInNonce = _taker\n  // if taker is not specified -- limitOrder for anyone to fill through Augustus or not -- taker = Zero, takerInNonce = Zero\n  taker: takerInNonce = ZERO_ADDRESS,\n  // if given, overrides the above choices made based on `taker`\n  contractTaker,\n  // for v6 only support taker=_taker for OTC orders\n  AppVersion,\n}: BuildOrderDataInput): SignableOrderData {\n  // first 160 bits is taker address (for p2p orders),\n  // or 0 for limitOrders, so that anyone can be the taker of the Order\n  const nonceAndMeta = (\n    BigInt(takerInNonce) +\n    (BigInt(nonce) << BigInt(160))\n  ).toString(10);\n\n  let taker: string;\n  // contractTaker overrides always\n  if (contractTaker) {\n    taker = contractTaker;\n  } else if (takerInNonce === ZERO_ADDRESS) {\n    // no takerInNonce -> not p2p order -> allow anyone to fill (not only Augustus)\n    taker = ZERO_ADDRESS;\n  } else {\n    // otherwise for p2p order ->\n    if (AppVersion.startsWith('6.')) {\n      //support 6.1+ versions\n\n      // limit taker to EOA for v6 version (no Arbitrary Token Swaps + OTC Fill, or OTC Fill through AugustusSwapper)\n      taker = takerInNonce;\n    } else {\n      // on v5\n      // -> fill through Augustus only\n      taker = AugustusAddress;\n    }\n  }\n\n  const order: OrderData = {\n    nonceAndMeta,\n    expiry,\n    makerAsset,\n    takerAsset,\n    maker,\n    taker,\n    makerAmount,\n    takerAmount,\n  };\n\n  return {\n    types: { Order },\n    domain: { name, version, chainId, verifyingContract },\n    data: order,\n  };\n}\n","import { DEFAULT_VERSION } from '../../constants';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { constructGetSpender } from '../swap/spender';\nimport {\n  buildOrderData,\n  BuildOrderDataInput,\n  SignableOrderData,\n} from './helpers/buildOrderData';\nexport * from './helpers/buildOrderData';\n\nexport type BuildLimitOrderInput = Omit<\n  BuildOrderDataInput,\n  'chainId' | 'verifyingContract' | 'AugustusAddress' | 'AppVersion'\n>;\n\ntype BuildLimitOrder = (\n  buildLimitOrderParams: BuildLimitOrderInput,\n  requestParams?: RequestParameters\n) => Promise<SignableOrderData>;\n\nexport type BuildLimitOrderFunctions = {\n  /** @description Build Orders that will be excuted through AugustusSwapper */\n  buildLimitOrder: BuildLimitOrder;\n};\n\nexport const constructBuildLimitOrder = (\n  options: ConstructFetchInput\n): BuildLimitOrderFunctions => {\n  const { chainId } = options;\n\n  // getContracts is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getContracts } = constructGetSpender(options);\n\n  const buildLimitOrder: BuildLimitOrder = async (\n    buildLimitOrderParams,\n    requestParams\n  ) => {\n    const { AugustusSwapper: AugustusAddress, AugustusRFQ: verifyingContract } =\n      await getContracts(requestParams);\n\n    const AppVersion = options.version ?? DEFAULT_VERSION;\n\n    return buildOrderData({\n      ...buildLimitOrderParams,\n      chainId,\n      verifyingContract,\n      AugustusAddress,\n      AppVersion,\n    });\n  };\n\n  return {\n    buildLimitOrder,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { SignableOrderData } from './buildOrder';\nimport { sanitizeOrderData } from './helpers/misc';\n\nexport type SignLimitOrderFunctions = {\n  signLimitOrder: (signableOrderData: SignableOrderData) => Promise<string>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructSignLimitOrder = (\n  options: Pick<\n    ConstructProviderFetchInput<any, 'signTypedDataCall'>,\n    'contractCaller'\n  >\n): SignLimitOrderFunctions => {\n  const signLimitOrder: SignLimitOrderFunctions['signLimitOrder'] = (\n    typedData\n  ) => {\n    // types allow to pass OrderData & extra_stuff, but tx will break like that\n    const typedDataOnly: SignableOrderData = {\n      ...typedData,\n      data: sanitizeOrderData(typedData.data),\n    };\n    return options.contractCaller.signTypedDataCall(typedDataOnly);\n  };\n\n  return { signLimitOrder };\n};\n","import type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n  TxSendOverrides,\n} from '../../types';\nimport { constructGetSpender } from '../swap/spender';\n\nexport type CancelOrder<T> = (\n  orderHash: string,\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<T>;\n\nexport type CancelOrderBulk<T> = (\n  orderHashes: string[],\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<T>;\n\nexport type CancelLimitOrderFunctions<T> = {\n  cancelLimitOrder: CancelOrder<T>;\n  cancelLimitOrderBulk: CancelOrderBulk<T>;\n};\n\n// much smaller than the whole AugustusRFQ_ABI\nconst MinAugustusRFQAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: 'orderHash',\n        type: 'bytes32',\n      },\n    ],\n    name: 'cancelOrder',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32[]',\n        name: 'orderHashes',\n        type: 'bytes32[]',\n      },\n    ],\n    name: 'cancelOrders',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype AvailableMethods = ExtractAbiMethodNames<typeof MinAugustusRFQAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructCancelLimitOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): CancelLimitOrderFunctions<T> => {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const cancelLimitOrder: CancelOrder<T> = async (\n    orderHash,\n    overrides = {},\n    requestParams\n  ) => {\n    const verifyingContract = await getAugustusRFQ(requestParams);\n\n    const res = await options.contractCaller.transactCall<AvailableMethods>({\n      // @CHECK if verifyingContract is the one we need to approve\n      // maybe a Proxy in-between\n      address: verifyingContract,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'cancelOrder',\n      args: [orderHash],\n      overrides,\n    });\n\n    return res;\n  };\n\n  const cancelLimitOrderBulk: CancelOrderBulk<T> = async (\n    orderHashes,\n    overrides = {},\n    requestParams\n  ) => {\n    const verifyingContract = await getAugustusRFQ(requestParams);\n\n    const res = await options.contractCaller.transactCall<AvailableMethods>({\n      // @CHECK if verifyingContract is the one we need to approve\n      // maybe a Proxy in-between\n      address: verifyingContract,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'cancelOrders',\n      args: [orderHashes],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return {\n    cancelLimitOrder,\n    cancelLimitOrderBulk,\n  };\n};\n","type SplitSignatureResult = {\n  v: number;\n  r: string;\n  s: string;\n  compact: string;\n};\n\nexport function splitSignature(signature: string): SplitSignatureResult {\n  // Remove \"0x\" prefix if present\n  if (signature.startsWith('0x')) {\n    signature = signature.slice(2);\n  }\n\n  // Convert the hex string to a byte array\n  const bytes = new Uint8Array(signature.length / 2);\n  for (let i = 0; i < signature.length; i += 2) {\n    bytes[i / 2] = parseInt(signature.slice(i, i + 2), 16);\n  }\n\n  // Validate the signature length (64 or 65 bytes)\n  if (bytes.length !== 64 && bytes.length !== 65) {\n    throw new Error('Invalid signature length: must be 64 or 65 bytes');\n  }\n\n  // Extract r and s components\n  const r = `0x${Array.from(bytes.slice(0, 32), (b) =>\n    b.toString(16).padStart(2, '0')\n  ).join('')}`;\n  let s: string;\n  let v;\n\n  // Handle 64-byte (EIP-2098 compact) and 65-byte signatures\n  if (bytes.length === 64) {\n    // Extract v from the highest bit of s and clear the bit in s\n    v = 27 + (bytes[32]! >> 7);\n    bytes[32]! &= 0x7f; // Clear the highest bit\n    s = `0x${Array.from(bytes.slice(32, 64))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('')}`;\n  } else {\n    s = `0x${Array.from(bytes.slice(32, 64))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('')}`;\n\n    // Extract v directly for 65-byte signature\n    v = bytes[64]!;\n\n    // Normalize v to canonical form (27 or 28)\n    if (v < 27) {\n      v += 27;\n    }\n  }\n\n  // Compute yParityAndS (_vs) for the compact signature\n  const sBytes = Array.from(bytes.slice(32, 64));\n  if (v === 28) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    sBytes[0]! |= 0x80; // Set the highest bit if v is 28\n  }\n  const yParityAndS = `0x${sBytes\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('')}`;\n\n  // Construct the compact signature by concatenating r and yParityAndS\n  const compactSignature = r + yParityAndS.slice(2);\n\n  return { v, r, s, compact: compactSignature };\n}\n","import { splitSignature } from './signature';\n\ntype EncodeEIP_2612PermitFunctionInput = {\n  permitSignature: string;\n  owner: string;\n  spender: string;\n  value: string | bigint;\n  deadline: string | number | bigint;\n};\n\n// encoding params for Token.permit() Permit1 function\nexport function encodeEIP_2612PermitFunctionInput({\n  owner,\n  spender,\n  value,\n  deadline,\n  permitSignature,\n}: EncodeEIP_2612PermitFunctionInput): string {\n  const { v, r, s } = splitSignature(permitSignature);\n\n  const encodedOwner = encodeAddress(owner);\n  const encodedSpender = encodeAddress(spender);\n  const encodedValue = encodeUint256(value);\n  const encodedDeadline = encodeUint256(deadline.toString());\n  const encodedV = encodeUint8(v);\n  const encodedR = encodeBytes32(r);\n  const encodedS = encodeBytes32(s);\n\n  // Concatenate all encoded values, stripping the \"0x\" prefix from each (except the first one)\n  return (\n    '0x' +\n    [\n      encodedOwner,\n      encodedSpender,\n      encodedValue,\n      encodedDeadline,\n      encodedV,\n      encodedR,\n      encodedS,\n    ]\n      .map((val) => val.slice(2)) // Remove \"0x\" prefix from each encoded value\n      .join('') // Concatenate the values\n  );\n}\n\ntype EncodeDAIlikePermitFunctionInput = {\n  permitSignature: string;\n  holder: string;\n  spender: string;\n  nonce: number | bigint | string;\n  expiry: number | bigint | string;\n};\n\n// encoding params for DAIlike.permit() function\nexport function encodeDAIlikePermitFunctionInput({\n  permitSignature,\n  holder,\n  spender,\n  nonce,\n  expiry,\n}: EncodeDAIlikePermitFunctionInput): string {\n  const { v, r, s } = splitSignature(permitSignature);\n\n  const encodedHolder = encodeAddress(holder);\n  const encodedSpender = encodeAddress(spender);\n  const encodedNonce = encodeUint256(nonce.toString());\n  const encodedExpiry = encodeUint256(expiry.toString());\n  const encodedV = encodeUint8(v);\n  const encodedR = encodeBytes32(r);\n  const encodedS = encodeBytes32(s);\n\n  // Concatenate all encoded values, stripping the \"0x\" prefix from each (except the first one)\n  return (\n    '0x' +\n    [\n      encodedHolder,\n      encodedSpender,\n      encodedNonce,\n      encodedExpiry,\n      encodeBool(true), //allowed=true\n      encodedV,\n      encodedR,\n      encodedS,\n    ]\n      .map((val) => val.slice(2)) // Remove \"0x\" prefix from each encoded value\n      .join('') // Concatenate the values\n  );\n}\n\n// encode an address (20 bytes) into 32 bytes\nexport function encodeAddress(address: string): string {\n  const strippedAddress = address.replace(/^0x/, ''); // Remove \"0x\" prefix\n  return '0x' + strippedAddress.toLowerCase().padStart(64, '0');\n}\n\n// encode a uint256 value\nexport function encodeUint256(value: string | bigint): string {\n  const bn = BigInt(value);\n  return '0x' + bn.toString(16).padStart(64, '0');\n}\n\n// encode a uint8 value\nexport function encodeUint8(value: number | bigint): string {\n  return '0x' + value.toString(16).padStart(64, '0');\n}\n\n// encode a bytes32 value\nexport function encodeBytes32(value: string): string {\n  const strippedValue = value.replace(/^0x/, ''); // Remove \"0x\" prefix\n  return '0x' + strippedValue.padStart(64, '0').toLowerCase();\n}\n\n//encode a boolean\nexport function encodeBool(value: boolean): string {\n  const encodedValue = value ? '1' : '0';\n  // padded to 32 bytes\n  return '0x' + encodedValue.padStart(64, '0');\n}\n\n/* \nconst EIP_2612_PERMIT_ABI = [\n  {\n    constant: false,\n    inputs: [\n      {\n        name: 'owner',\n        type: 'address',\n      },\n      {\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        name: 'value',\n        type: 'uint256',\n      },\n      {\n        name: 'deadline',\n        type: 'uint256',\n      },\n      {\n        name: 'v',\n        type: 'uint8',\n      },\n      {\n        name: 'r',\n        type: 'bytes32',\n      },\n      {\n        name: 's',\n        type: 'bytes32',\n      },\n    ],\n    name: 'permit',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n]; \n*/\n\n/* \nconst DAI_EIP_2612_PERMIT_ABI = [\n  {\n    constant: false,\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'holder',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: 'spender',\n        type: 'address',\n      },\n      {\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        internalType: 'uint256',\n        name: 'expiry',\n        type: 'uint256',\n      },\n      {\n        internalType: 'bool',\n        name: 'allowed',\n        type: 'bool',\n      },\n      {\n        internalType: 'uint8',\n        name: 'v',\n        type: 'uint8',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'r',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes32',\n        name: 's',\n        type: 'bytes32',\n      },\n    ],\n    name: 'permit',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n];\n */\n","import type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n  TxSendOverrides,\n} from '../../types';\nimport type { OrderData } from './buildOrder';\nimport { constructGetSpender } from '../swap/spender';\nimport { sanitizeOrderData } from './helpers/misc';\nimport {\n  encodeDAIlikePermitFunctionInput,\n  encodeEIP_2612PermitFunctionInput,\n} from '../common/orders/encoding';\n\nexport type FillOrderDirectlyFunctions<T> = {\n  fillOrderDirectly: FillOrderDirectly<T>;\n};\n\ntype TakerPermitEncodedInputParams = {\n  encodedPermitParams: string;\n};\n\ntype TakerPermit1Data = {\n  signature: string;\n  deadline: number | bigint | string;\n  amount?: string;\n  isDaiPermit?: false;\n};\n\ntype TakerDaiPermitData = {\n  signature: string;\n  expiry: number | bigint | string;\n  nonce: number | bigint | string;\n  isDaiPermit: true;\n};\n\ntype TakerPermitObject =\n  | TakerPermitEncodedInputParams\n  | TakerPermit1Data\n  | TakerDaiPermitData;\n\nexport type FillOrderDirectly<T> = (\n  orderFillData: {\n    order: OrderData;\n    signature: string;\n    /** @description Permit1 data or DAI Permit data or Token.parmit() input params encoded; Permit by taker for Taker Asset with AugustusRFQ as spender */\n    takerPermit?: TakerPermitObject;\n  },\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<T>;\n\n// much smaller than the whole AugustusRFQ_ABI\nconst MinAugustusRFQAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'nonceAndMeta',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint128',\n            name: 'expiry',\n            type: 'uint128',\n          },\n          {\n            internalType: 'address',\n            name: 'makerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'takerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'maker',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'taker',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerAmount',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerAmount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct AugustusRFQ.Order',\n        name: 'order',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'signature',\n        type: 'bytes',\n      },\n    ],\n    name: 'fillOrder',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'nonceAndMeta',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint128',\n            name: 'expiry',\n            type: 'uint128',\n          },\n          {\n            internalType: 'address',\n            name: 'makerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'takerAsset',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'maker',\n            type: 'address',\n          },\n          {\n            internalType: 'address',\n            name: 'taker',\n            type: 'address',\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerAmount',\n            type: 'uint256',\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerAmount',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct AugustusRFQ.Order',\n        name: 'order',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes',\n        name: 'signature',\n        type: 'bytes',\n      },\n      {\n        internalType: 'uint256',\n        name: 'takerTokenFillAmount',\n        type: 'uint256',\n      },\n      {\n        internalType: 'address',\n        name: 'target',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes',\n        name: 'permitTakerAsset',\n        type: 'bytes',\n      },\n      {\n        internalType: 'bytes',\n        name: 'permitMakerAsset',\n        type: 'bytes',\n      },\n    ],\n    name: 'partialFillOrderWithTargetPermit',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'makerTokenFilledAmount',\n        type: 'uint256',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype FillOrderMethods = ExtractAbiMethodNames<typeof MinAugustusRFQAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport function constructFillOrderDirectly<T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): FillOrderDirectlyFunctions<T> {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const fillOrderDirectly: FillOrderDirectly<T> = async (\n    { order, signature, takerPermit },\n    overrides = {},\n    requestParams\n  ) => {\n    const AugustusRFQ = await getAugustusRFQ(requestParams);\n\n    const sanitizedOrder = sanitizeOrderData(order);\n\n    if (!takerPermit) {\n      const res = await options.contractCaller.transactCall<FillOrderMethods>({\n        address: AugustusRFQ,\n        abi: MinAugustusRFQAbi,\n        contractMethod: 'fillOrder',\n        args: [sanitizedOrder, signature],\n        overrides,\n      });\n\n      return res;\n    }\n\n    let permitTakerAsset: string;\n    if ('encodedPermitParams' in takerPermit) {\n      permitTakerAsset = takerPermit.encodedPermitParams;\n    } else if ('isDaiPermit' in takerPermit && takerPermit.isDaiPermit) {\n      // encoded DAI.permit() function params by taker with AugustusRFQ as spender\n      permitTakerAsset = encodeDAIlikePermitFunctionInput({\n        holder: order.taker,\n        spender: AugustusRFQ,\n        expiry: takerPermit.expiry,\n        nonce: takerPermit.nonce,\n        permitSignature: takerPermit.signature,\n      });\n    } else {\n      // encoded TakerAsset.permit() function params by taker with AugustusRFQ as spender, Permit1 only\n      permitTakerAsset = encodeEIP_2612PermitFunctionInput({\n        owner: order.taker,\n        spender: AugustusRFQ,\n        value: takerPermit.amount || order.takerAmount, // can use permit with a bigger value, fallback to exact Order takerAmount\n        deadline: takerPermit.deadline,\n        permitSignature: takerPermit.signature,\n      });\n    }\n\n    const res = await options.contractCaller.transactCall<FillOrderMethods>({\n      address: AugustusRFQ,\n      abi: MinAugustusRFQAbi,\n      contractMethod: 'partialFillOrderWithTargetPermit',\n      args: [\n        sanitizedOrder, // order\n        signature, // order.signature\n        order.takerAmount, // takerTokenFillAmount, can even partially fill\n        order.taker, // target\n        permitTakerAsset,\n        '0x', // permitMakerAsset, unused because hard to account for changing nonce for long running Orders\n      ],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return { fillOrderDirectly };\n}\n","// @TODO getOrder, getOrders from API\n// onchain from contract can't distinguish between filled or cancelled\nimport { API_URL } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\nimport {\n  constructBaseFetchUrlGetter,\n  GetOrdersURLs,\n  GetOrderURL,\n  GetRequiredAllowanceURL as GetRequiredBalanceURL,\n} from './helpers/misc';\nimport type {\n  LimitOrderFromApi,\n  LimitOrdersApiResponse,\n  LimitOrderType,\n} from './helpers/types';\n\ntype PaginationParams = {\n  limit?: number;\n  offset?: number;\n  hideSmallBalances?: boolean;\n  orderBy?: 'createdAt' | 'updatedAt' | 'expiry';\n};\n\n//                     get orders by `maker` or `taker`\nexport type LimitOrdersUserParams = (\n  | { maker: Address; type: LimitOrderType }\n  | { taker: Address; type: LimitOrderType }\n) &\n  PaginationParams;\n\nexport type GetRequiredAllowanceParams = {\n  maker: Address;\n  token?: Address;\n};\n\ntype GetLimitOrderByHash = (\n  orderHash: string,\n  requestParams?: RequestParameters\n) => Promise<LimitOrderFromApi>;\ntype GetLimitOrders = (\n  userParams: LimitOrdersUserParams,\n  requestParams?: RequestParameters\n) => Promise<LimitOrdersApiResponse>;\n\ntype GetRequiredBalance = (\n  userParams: GetRequiredAllowanceParams,\n  requestParams?: RequestParameters\n) => Promise<Record<string, string>>;\n\nexport type GetLimitOrdersFunctions = {\n  getLimitOrders: GetLimitOrders;\n  getLimitOrderByHash: GetLimitOrderByHash;\n  /**\n   * Gets fillableBalance for tokens from user's active orders.\n   * User needs to have enough balance & allowance to cover active orders before creating new orders.\n   * @param userParams - parameters to get allowance for active orders\n   * @param {string} userParams.maker - user to get required allowances for\n   * @param {string=} userParams.token - if given `token`, the mapping will contain that token address only\n   * @param {RequestParameters=} requestParams - requestParams passed to fetcher, can include {signal: AbortSignal, timeout: for axios, etc.}\n   * @returns `{Lowercase<Address> => wei number as string}` mapping of token to fillableBalance\n   */\n  getRequiredBalance: GetRequiredBalance;\n};\n\nexport const constructGetLimitOrders = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetLimitOrdersFunctions => {\n  const getBaseFetchURLByEntityType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const getLimitOrders: GetLimitOrders = async (userParams, requestParams) => {\n    const baseFetchURL = getBaseFetchURLByEntityType(userParams.type);\n    const userURL =\n      'maker' in userParams\n        ? (`maker/${userParams.maker}` as const)\n        : (`taker/${userParams.taker}` as const);\n\n    const { offset, limit, hideSmallBalances, orderBy } = userParams;\n    const search = constructSearchString<PaginationParams>({\n      offset,\n      limit,\n      hideSmallBalances,\n      orderBy,\n    });\n\n    const fetchURL = `${baseFetchURL}/${userURL}${search}` as const;\n\n    const response = await fetcher<LimitOrdersApiResponse, GetOrdersURLs>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getRequiredBalance: GetRequiredBalance = async (\n    userParams,\n    requestParams\n  ) => {\n    const baseFetchURL = getBaseFetchURLByEntityType('fillablebalance');\n    const userURL = `${baseFetchURL}/${userParams.maker}` as const;\n    const fetchURL = userParams.token\n      ? (`${userURL}/${userParams.token}` as const)\n      : userURL;\n\n    const response = await fetcher<\n      Record<string, string>,\n      GetRequiredBalanceURL\n    >({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getLimitOrderByHash: GetLimitOrderByHash = async (\n    orderHash,\n    requestParams\n  ) => {\n    const baseFetchURL = getBaseFetchURLByEntityType();\n    const fetchURL = `${baseFetchURL}/${orderHash}` as const;\n\n    const order = await fetcher<LimitOrderFromApi, GetOrderURL>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return order;\n  };\n\n  return {\n    getLimitOrders,\n    getLimitOrderByHash,\n    getRequiredBalance,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { constructBaseFetchUrlGetter, PostOrderURLs } from './helpers/misc';\nimport type {\n  LimitOrderApiResponse,\n  LimitOrderToSend,\n  LimitOrderFromApi,\n  LimitOrderType,\n} from './helpers/types';\n\ntype PostLimitOrder = (\n  limitOrderWithSignatureAndPermit: LimitOrderToSend,\n  requestParams?: RequestParameters\n) => Promise<LimitOrderFromApi>;\n\nexport type PostLimitOrderFunctions = {\n  postLimitOrder: PostLimitOrder;\n  postP2POrder: PostLimitOrder;\n};\n\nexport const constructPostLimitOrder = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): PostLimitOrderFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const postTypedOrder = async (\n    limitOrderWithSignatureAndPermit: LimitOrderToSend,\n    type: LimitOrderType,\n    requestParams?: RequestParameters\n  ): Promise<LimitOrderFromApi> => {\n    const fetchURL = getBaseFetchURLByOrderType(type);\n\n    const { order: newOrder } = await fetcher<\n      LimitOrderApiResponse,\n      PostOrderURLs\n    >({\n      url: fetchURL,\n      method: 'POST',\n      data: limitOrderWithSignatureAndPermit,\n      requestParams,\n    });\n\n    return newOrder;\n  };\n\n  const postLimitOrder: PostLimitOrder = (\n    limitOrderWithSignatureAndPermit,\n    requestParams\n  ) => {\n    return postTypedOrder(\n      limitOrderWithSignatureAndPermit,\n      'LIMIT',\n      requestParams\n    );\n  };\n\n  const postP2POrder: PostLimitOrder = (\n    limitOrderWithSignatureAndPermit,\n    requestParams\n  ) => {\n    return postTypedOrder(\n      limitOrderWithSignatureAndPermit,\n      'P2P',\n      requestParams\n    );\n  };\n\n  return { postLimitOrder, postP2POrder };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport { ApproveToken, approveTokenMethodFactory } from '../../helpers/approve';\nimport { constructApproveToken } from '../swap/approve';\nimport { constructGetSpender } from '../swap/spender';\n\nexport type ApproveTokenForLimitOrderFunctions<T> = {\n  /** @description approving AugustusRFQ as spender for makerAsset */\n  approveMakerTokenForLimitOrder: ApproveToken<T>;\n  /** @description approving AugustusRFQ as spender for takerAsset to call SDK.fillOrderDirectly */\n  approveTakerTokenForFillingP2POrderDirectly: ApproveToken<T>;\n  /** @description approving AugustusSwapper as spender for takerAsset for Limit Orders that will be executed through it */\n  approveTakerTokenForLimitOrder: ApproveToken<T>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveTokenForLimitOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenForLimitOrderFunctions<T> => {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getAugustusRFQ } = constructGetSpender(options);\n\n  const approveMakerTokenForLimitOrder: ApproveToken<T> =\n    approveTokenMethodFactory<T>(options.contractCaller, getAugustusRFQ);\n\n  // approving TokenTransaferProxy as for the swap\n  const { approveToken: approveTakerTokenForLimitOrder } =\n    constructApproveToken(options);\n\n  return {\n    approveMakerTokenForLimitOrder,\n    approveTakerTokenForFillingP2POrderDirectly: approveMakerTokenForLimitOrder,\n    approveTakerTokenForLimitOrder,\n  };\n};\n","import type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender, GetSpender } from '../swap/spender';\n\nexport type GetLimitOrdersContractFunctions = {\n  getLimitOrdersContract: GetSpender;\n  getTokenTransferProxy: GetSpender;\n};\n\nexport const constructGetLimitOrdersContract = (\n  options: ConstructFetchInput\n): GetLimitOrdersContractFunctions => {\n  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ\n\n  const {\n    getSpender: getTokenTransferProxy,\n    getAugustusRFQ: getLimitOrdersContract,\n  } = constructGetSpender(options);\n\n  return { getLimitOrdersContract, getTokenTransferProxy };\n};\n","import type { ConstructFetchInput, OptimalRate } from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport {\n  API_URL,\n  SwapSide,\n  ContractMethod,\n  DEFAULT_VERSION,\n} from '../../constants';\nimport {\n  BuildLimitOrderTxInput,\n  BuildOptions,\n  BuildSwapAndLimitOrderTxInput,\n  TransactionParams,\n  constructBuildTx,\n} from '../swap/transaction';\nimport { constructGetRate, GetRateInput, RateOptions } from '../swap/rates';\nimport type { OrderData } from './buildOrder';\nimport { isFilledArray } from '../../helpers/misc';\nimport type { RequestParameters } from '../../types';\n\ntype MinBuildSwapAndLimitOrderTxInput = Omit<\n  // these are derived from `orders`\n  BuildSwapAndLimitOrderTxInput,\n  'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'\n>;\n\ntype BuildSwapAndLimitOrdersTx = (\n  params: MinBuildSwapAndLimitOrderTxInput,\n  options?: BuildOptions,\n  requestParams?: RequestParameters\n) => Promise<TransactionParams>;\n\ntype MinBuildLimitOrderTxInput = Omit<\n  BuildLimitOrderTxInput,\n  // these are derived from `orders`\n  'srcToken' | 'srcAmount' | 'destToken' | 'slippage'\n  // `slippage` doesn't participate as we derive `srcAmount` already\n>;\n\ntype BuildLimitOrdersTx = (\n  params: MinBuildLimitOrderTxInput,\n  options?: BuildOptions,\n  requestParams?: RequestParameters\n) => Promise<TransactionParams>;\n\nexport type BuildLimitOrdersTxFunctions = {\n  getLimitOrdersRate: GetLimitOrdersRate;\n  buildLimitOrderTx: BuildLimitOrdersTx;\n  buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx;\n};\n\ntype GetLimitOrdersRate = (\n  // `amount`, if given, must equal the total of the orders' `takerAmounts`\n  options: Omit<GetRateInput, 'amount' | 'side'> & { amount?: string },\n  orders: CheckableOrderData[],\n  requestParams?: RequestParameters\n) => Promise<OptimalRate>;\n\nexport const constructBuildLimitOrderTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildLimitOrdersTxFunctions => {\n  const { buildTx: buildSwapTx } = constructBuildTx({\n    apiURL,\n    chainId,\n    fetcher,\n    version,\n  });\n\n  const { getRate: getSwapAndLimitOrderRate } = constructGetRate({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  //  returns priceRoute that would allow to swap from srcToken to destToken(=order.takerAsset) followed by filling limit orders\n  const getLimitOrdersRate: GetLimitOrdersRate = async (\n    { srcToken, destToken, amount, options: _options = {}, ...rest },\n    orders,\n    requestParams\n  ) => {\n    assert(orders.length > 0, 'must pass at least 1 order');\n\n    const { totalTakerAmount, takerAsset } = checkAndParseOrders(orders);\n    assert(\n      takerAsset.toLowerCase() === destToken.toLowerCase(),\n      'All orders must have the same takerAsset as destToken'\n    );\n\n    const takerAmountString = totalTakerAmount.toString(10);\n\n    if (amount) {\n      assert(\n        amount === takerAmountString,\n        \"`amount` must equal the total of the orders' `takerAmounts`\"\n      );\n    }\n\n    // The pricing must use includeContractMethods=simpleBuy and side=BUY\n    const options: RateOptions = {\n      ..._options,\n      includeContractMethods: [ContractMethod.simpleBuy],\n    };\n\n    const side = SwapSide.BUY;\n\n    const rateInput: GetRateInput = {\n      ...rest,\n      srcToken,\n      destToken,\n      amount: takerAmountString,\n      side,\n      options,\n    };\n\n    // priceRoute\n    const optimalRate = await getSwapAndLimitOrderRate(\n      rateInput,\n      requestParams\n    );\n    return optimalRate;\n  };\n\n  // derive srcToken, destToken and srcAmount from orders[]\n  const buildLimitOrderTx: BuildLimitOrdersTx = (\n    params,\n    options,\n    requestParams\n  ) => {\n    const { makerAsset, takerAsset, totalTakerAmount } = checkAndParseOrders(\n      params.orders\n    );\n\n    const fillParams: BuildLimitOrderTxInput = {\n      ...params,\n      // taker supplies takerAsset\n      srcToken: takerAsset,\n      // no `slippage` in `params`\n      srcAmount: totalTakerAmount.toString(10),\n      // taker gets makerAsset in the end\n      destToken: makerAsset,\n    };\n\n    return buildSwapTx(fillParams, options, requestParams);\n  };\n\n  const buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx = (\n    params,\n    options,\n    requestParams\n  ) => {\n    const { makerAsset } = checkAndParseOrders(params.orders);\n\n    const fillParams: BuildSwapAndLimitOrderTxInput = {\n      ...params,\n      // taker supplies srcToken\n      srcToken: params.priceRoute.srcToken,\n      // which is swapped for makerAsset, that would go towards filling the orders\n      destToken: makerAsset,\n      destDecimals: params.priceRoute.destDecimals,\n      // one or the other\n      ...(params.slippage\n        ? { slippage: params.slippage }\n        : //                                        may sneak in as part of `params`\n          { srcAmount: params.priceRoute.srcAmount, slippage: undefined }),\n    };\n\n    return buildSwapTx(fillParams, options, requestParams);\n  };\n\n  return {\n    getLimitOrdersRate,\n    buildLimitOrderTx,\n    buildSwapAndLimitOrderTx,\n  };\n};\n\ntype CheckAndParseOrdersResult = Omit<CheckableOrderData, 'takerAmount'> & {\n  totalTakerAmount: bigint;\n};\n\ntype CheckableOrderData = Pick<\n  OrderData,\n  'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'\n> & { taker?: OrderData['taker'] };\n\nfunction checkAndParseOrders(\n  orders: CheckableOrderData[]\n): CheckAndParseOrdersResult {\n  assert(isFilledArray(orders), 'must pass at least 1 order');\n\n  const { takerAssetsSet, makerAssetsSet, totalTakerAmount } = orders.reduce<\n    Record<'takerAssetsSet' | 'makerAssetsSet', Set<string>> & {\n      totalTakerAmount: bigint;\n    }\n  >(\n    (accum, order) => {\n      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());\n      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());\n\n      accum.totalTakerAmount =\n        accum.totalTakerAmount + BigInt(order.takerAmount);\n      return accum;\n    },\n    {\n      takerAssetsSet: new Set(),\n      makerAssetsSet: new Set(),\n      totalTakerAmount: BigInt(0),\n    }\n  );\n\n  assert(\n    takerAssetsSet.size === 1,\n    'All orders must have the same takerAsset as destToken'\n  );\n  assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');\n\n  const [{ maker, taker, makerAsset, takerAsset }] = orders;\n\n  return {\n    totalTakerAmount,\n    maker,\n    taker,\n    makerAsset,\n    takerAsset,\n  };\n}\n","import type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { constructGetSpender } from '../swap/spender';\nimport {\n  buildOrderData,\n  BuildNFTOrderDataInput,\n  SignableNFTOrderData,\n} from './helpers/buildOrderData';\nexport * from './helpers/buildOrderData';\n\nexport type BuildNFTOrderInput = Omit<\n  BuildNFTOrderDataInput,\n  'chainId' | 'verifyingContract' | 'AugustusAddress'\n>;\n\ntype BuildNFTOrder = (\n  buildNFTOrderParams: BuildNFTOrderInput,\n  requestParams?: RequestParameters\n) => Promise<SignableNFTOrderData>;\n\nexport type BuildNFTOrderFunctions = {\n  /** @description Build Orders that will be excuted through AugustusSwapper */\n  buildNFTOrder: BuildNFTOrder;\n};\n\nexport const constructBuildNFTOrder = (\n  options: ConstructFetchInput\n): BuildNFTOrderFunctions => {\n  const { chainId } = options;\n\n  // getContracts is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getContracts } = constructGetSpender(options);\n\n  const buildNFTOrder: BuildNFTOrder = async (\n    buildNFTOrderParams,\n    requestParams\n  ) => {\n    const { AugustusSwapper: AugustusAddress, AugustusRFQ: verifyingContract } =\n      await getContracts(requestParams);\n\n    return buildOrderData({\n      ...buildNFTOrderParams,\n      chainId,\n      verifyingContract,\n      AugustusAddress,\n    });\n  };\n\n  return {\n    buildNFTOrder,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { SignableNFTOrderData } from './buildOrder';\nimport { sanitizeOrderData } from './helpers/misc';\n\nexport type SignNFTOrderFunctions = {\n  signNFTOrder: (signableOrderData: SignableNFTOrderData) => Promise<string>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructSignNFTOrder = (\n  options: Pick<\n    ConstructProviderFetchInput<any, 'signTypedDataCall'>,\n    'contractCaller'\n  >\n): SignNFTOrderFunctions => {\n  const signNFTOrder: SignNFTOrderFunctions['signNFTOrder'] = (typedData) => {\n    // types allow to pass OrderData & extra_stuff, but tx will break like that\n    const typedDataOnly: SignableNFTOrderData = {\n      ...typedData,\n      // here assetType isn't provided, SignableData must already have corrent BigIntAsString\n      // @TODO consider using `template_${types}` for Address, likely bad idea when considering 3rd-party code\n      data: sanitizeOrderData(typedData.data),\n    };\n    return options.contractCaller.signTypedDataCall(typedDataOnly);\n  };\n\n  return { signNFTOrder };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport {\n  CancelOrder,\n  CancelOrderBulk,\n  constructCancelLimitOrder,\n} from '../limitOrders/cancelOrder';\n\nexport type CancelNFTOrderFunctions<T> = {\n  cancelNFTOrder: CancelOrder<T>;\n  cancelNFTOrderBulk: CancelOrderBulk<T>;\n};\n\n// should work the same as for LimitOrders\nexport const constructCancelNFTOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): CancelNFTOrderFunctions<T> => {\n  const { cancelLimitOrder, cancelLimitOrderBulk } =\n    constructCancelLimitOrder(options);\n  return {\n    cancelNFTOrder: cancelLimitOrder,\n    cancelNFTOrderBulk: cancelLimitOrderBulk,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\nimport {\n  constructBaseFetchUrlGetter,\n  GetOrdersURLs,\n  GetOrderURL,\n} from './helpers/misc';\nimport type {\n  NFTOrderFromAPI,\n  NFTOrdersApiResponse,\n  NFTOrderType,\n} from './helpers/types';\n\n//                     get orders by `maker` or `taker`\nexport type NFTOrdersUserParams =\n  | { maker: Address; type: NFTOrderType }\n  | { taker: Address; type: NFTOrderType };\ntype GetNFTOrderByHash = (\n  orderHash: string,\n  requestParams?: RequestParameters\n) => Promise<NFTOrderFromAPI>;\ntype GetNFTOrders = (\n  userParams: NFTOrdersUserParams,\n  requestParams?: RequestParameters\n) => Promise<NFTOrdersApiResponse>;\n\nexport type GetNFTOrdersFunctions = {\n  getNFTOrders: GetNFTOrders;\n  getNFTOrderByHash: GetNFTOrderByHash;\n};\n\nexport const constructGetNFTOrders = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetNFTOrdersFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const getNFTOrders: GetNFTOrders = async (userParams, requestParams) => {\n    const baseFetchURL = getBaseFetchURLByOrderType(userParams.type);\n    const userURL =\n      'maker' in userParams\n        ? (`maker/${userParams.maker}` as const)\n        : (`taker/${userParams.taker}` as const);\n    const fetchURL = `${baseFetchURL}/${userURL}` as const;\n\n    const response = await fetcher<NFTOrdersApiResponse, GetOrdersURLs>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    // without any extra calls, return  what API returns\n    return response;\n  };\n\n  const getNFTOrderByHash: GetNFTOrderByHash = async (\n    orderHash,\n    requestParams\n  ) => {\n    const baseFetchURL = getBaseFetchURLByOrderType();\n    const fetchURL = `${baseFetchURL}/${orderHash}` as const;\n\n    const order = await fetcher<NFTOrderFromAPI, GetOrderURL>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return order;\n  };\n\n  return {\n    getNFTOrders,\n    getNFTOrderByHash,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { constructBaseFetchUrlGetter, PostOrderURLs } from './helpers/misc';\nimport type {\n  NFTOrderToSend,\n  NFTOrderType,\n  NFTOrderFromAPI,\n  NFTOrderApiResponse,\n} from './helpers/types';\n\ntype PostNFTOrder = (\n  NFTOrderWithSignatureAndPermit: NFTOrderToSend,\n  requestParams?: RequestParameters\n) => Promise<NFTOrderFromAPI>;\n\nexport type PostNFTOrderFunctions = {\n  postNFTLimitOrder: PostNFTOrder;\n  postNFTP2POrder: PostNFTOrder;\n};\n\nexport const constructPostNFTOrder = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): PostNFTOrderFunctions => {\n  const getBaseFetchURLByOrderType = constructBaseFetchUrlGetter({\n    apiURL,\n    chainId,\n  });\n\n  const postTypedOrder = async (\n    NFTOrderWithSignatureAndPermit: NFTOrderToSend,\n    type: NFTOrderType,\n    requestParams?: RequestParameters\n  ): Promise<NFTOrderFromAPI> => {\n    const fetchURL = getBaseFetchURLByOrderType(type);\n\n    // @TODO check API return matches\n    const { order: newOrder } = await fetcher<\n      NFTOrderApiResponse,\n      PostOrderURLs\n    >({\n      url: fetchURL,\n      method: 'POST',\n      data: NFTOrderWithSignatureAndPermit,\n      requestParams,\n    });\n\n    return { ...newOrder };\n  };\n\n  const postNFTLimitOrder: PostNFTOrder = (\n    NFTOrderWithSignatureAndPermit,\n    requestParams\n  ) => {\n    return postTypedOrder(\n      NFTOrderWithSignatureAndPermit,\n      'LIMIT',\n      requestParams\n    );\n  };\n\n  const postNFTP2POrder: PostNFTOrder = (\n    NFTOrderWithSignatureAndPermit,\n    requestParams\n  ) => {\n    return postTypedOrder(NFTOrderWithSignatureAndPermit, 'P2P', requestParams);\n  };\n\n  return { postNFTLimitOrder, postNFTP2POrder };\n};\n","import type { ConstructFetchInput } from '../../types';\nimport { constructGetSpender, GetSpender } from '../swap/spender';\n\nexport type GetNFTOrdersContractFunctions = {\n  getNFTOrdersContract: GetSpender;\n  getTokenTransferProxy: GetSpender;\n};\n\n// should work the same as LimitOrders\nexport const constructGetNFTOrdersContract = (\n  options: ConstructFetchInput\n): GetNFTOrdersContractFunctions => {\n  // analogous to getSpender() but for Limit Orders Contract = AugustusRFQ\n\n  const {\n    getSpender: getTokenTransferProxy,\n    getAugustusRFQ: getNFTOrdersContract,\n  } = constructGetSpender(options);\n\n  return {\n    getNFTOrdersContract,\n    getTokenTransferProxy,\n  };\n};\n","import type { ApproveToken } from '../../helpers/approve';\nimport type { ExtractAbiMethodNames } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructProviderFetchInput,\n  RequestParameters,\n  TxSendOverrides,\n} from '../../types';\nimport { constructApproveToken } from '../swap/approve';\nimport { constructGetNFTOrdersContract } from './getOrdersContract';\n\ntype ApproveNFT<T> = (\n  tokenAddress: Address,\n  overrides?: TxSendOverrides,\n  requestParams?: RequestParameters\n) => Promise<T>;\n\nexport type ApproveTokenForNFTOrderFunctions<T> = {\n  /** @description approving AugustusSwapper as spender for takerAsset (ERC20) for Limit Orders that will be executed through it */\n  approveERC20ForNFTOrder: ApproveToken<T>;\n  /** @description approving AugustusRFQ as spender for makerAsset (NFT) */\n  approveNFTForNFTOrder: ApproveNFT<T>;\n};\n\nconst MinNFTAbi = [\n  {\n    constant: false,\n    inputs: [\n      {\n        name: '_operator',\n        type: 'address',\n      },\n      {\n        name: '_approved',\n        type: 'bool',\n      },\n    ],\n    name: 'setApprovalForAll',\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ntype ApprovalMethods = ExtractAbiMethodNames<typeof MinNFTAbi>;\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveTokenForNFTOrder = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenForNFTOrderFunctions<T> => {\n  // approving TokenTransaferProxy as for the swap\n  const { approveToken: approveERC20ForNFTOrder } =\n    constructApproveToken(options);\n\n  const { getNFTOrdersContract } = constructGetNFTOrdersContract(options);\n\n  const approveNFTForNFTOrder: ApproveNFT<T> = async (\n    tokenAddress,\n    overrides = {},\n    requestParams\n  ) => {\n    // @TODO add approvetakerAssetForNFTOrder to use AugustusSwapper as spender if we ever have SELL NFT swaps\n    const AugustusRFQ = await getNFTOrdersContract(requestParams);\n\n    const res = await options.contractCaller.transactCall<ApprovalMethods>({\n      address: tokenAddress,\n      abi: MinNFTAbi,\n      contractMethod: 'setApprovalForAll',\n      args: [AugustusRFQ, true],\n      overrides,\n    });\n\n    return res;\n  };\n\n  return { approveERC20ForNFTOrder, approveNFTForNFTOrder };\n};\n","import type { Address, ConstructFetchInput, OptimalRate } from '../../types';\n\nimport { assert } from 'ts-essentials';\nimport {\n  API_URL,\n  SwapSide,\n  ContractMethod,\n  DEFAULT_VERSION,\n} from '../../constants';\nimport {\n  BuildNFTOrderTxInput,\n  BuildOptions,\n  BuildSwapAndNFTOrderTxInput,\n  TransactionParams,\n  constructBuildTx,\n} from '../swap/transaction';\nimport { constructGetRate, GetRateInput, RateOptions } from '../swap/rates';\nimport type { BigIntAsString, NFTOrderData } from './buildOrder';\nimport { isFilledArray } from '../../helpers/misc';\nimport type { RequestParameters } from '../../types';\ntype MinBuildSwapAndNFTOrderTxInput = Omit<\n  // these are derived from `orders`\n  BuildSwapAndNFTOrderTxInput,\n  'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'\n>;\n\ntype BuildSwapAndNFTOrdersTx = (\n  params: MinBuildSwapAndNFTOrderTxInput,\n  options?: BuildOptions,\n  requestParams?: RequestParameters\n) => Promise<TransactionParams>;\n\ntype MinBuildNFTOrderTxInput = Omit<\n  BuildNFTOrderTxInput,\n  // these are derived from `orders`\n  'srcToken' | 'srcAmount' | 'destToken' | 'slippage'\n  // `slippage` doesn't participate as we derive `srcAmount` already\n>;\n\ntype BuildNFTOrdersTx = (\n  params: MinBuildNFTOrderTxInput,\n  options?: BuildOptions,\n  requestParams?: RequestParameters\n) => Promise<TransactionParams>;\n\nexport type BuildNFTOrdersTxFunctions = {\n  getNFTOrdersRate: GetNFTOrdersRate;\n  buildNFTOrderTx: BuildNFTOrdersTx;\n  buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx;\n};\n\ntype GetNFTOrdersRate = (\n  // `amount`, if given, must equal the total of the orders' `takerAmounts`\n  options: Omit<GetRateInput, 'amount' | 'side'> & { amount?: string },\n  orders: CheckableOrderData[],\n  requestParams?: RequestParameters\n) => Promise<OptimalRate>;\n\nexport const constructBuildNFTOrderTx = ({\n  apiURL = API_URL,\n  version = DEFAULT_VERSION,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): BuildNFTOrdersTxFunctions => {\n  const { buildTx: buildSwapTx } = constructBuildTx({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  const { getRate: getSwapAndNFTOrderRate } = constructGetRate({\n    apiURL,\n    version,\n    chainId,\n    fetcher,\n  });\n\n  //  returns priceRoute that would allow from swap from srcToken to destToken(=order.takerAsset) followed by filling NFT orders\n  const getNFTOrdersRate: GetNFTOrdersRate = async (\n    { srcToken, destToken, amount, options: _options = {}, ...rest },\n    orders,\n    requestParams\n  ) => {\n    assert(orders.length > 0, 'must pass at least 1 order');\n\n    const { totalTakerAmount, takerAsset } = checkAndParseOrders(orders);\n\n    assert(\n      takerAsset.toLowerCase() === destToken.toLowerCase(),\n      'All orders must have the same takerAsset as destToken'\n    );\n\n    const takerAmountString = totalTakerAmount.toString(10);\n\n    if (amount) {\n      assert(\n        amount === takerAmountString,\n        \"`amount` must equal the total of the orders' `takerAmounts`\"\n      );\n    }\n\n    // The pricing must use includeContractMethods=simpleBuy and side=BUY\n    const options: RateOptions = {\n      ..._options,\n      includeContractMethods: [ContractMethod.simpleBuy],\n    };\n\n    const side = SwapSide.BUY;\n\n    const rateInput: GetRateInput = {\n      ...rest,\n      srcToken,\n      destToken,\n      amount: takerAmountString,\n      side,\n      options,\n    };\n\n    // priceRoute\n    const optimalRate = await getSwapAndNFTOrderRate(rateInput, requestParams);\n    return optimalRate;\n  };\n\n  // derive srcToken, destToken and srcAmount from orders[]\n  const buildNFTOrderTx: BuildNFTOrdersTx = (\n    params,\n    options,\n    requestParams\n  ) => {\n    const { takerAsset, totalTakerAmount } = checkAndParseOrders(params.orders);\n\n    const fillParams: BuildNFTOrderTxInput = {\n      ...params,\n      // taker supplies takerAsset\n      srcToken: takerAsset,\n      srcAmount: totalTakerAmount.toString(10),\n      // taker gets makerAsset in the end\n      destToken: 'NFT', // support any NFT\n    };\n\n    return buildSwapTx(fillParams, options, requestParams);\n  };\n  const buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx = (\n    params,\n    options,\n    requestParams\n  ) => {\n    checkAndParseOrders(params.orders);\n\n    const fillParams: BuildSwapAndNFTOrderTxInput = {\n      ...params,\n      // taker supplies srcToken\n      srcToken: params.priceRoute.srcToken,\n      // one or the other\n      ...(params.slippage\n        ? { slippage: params.slippage }\n        : //                                        may sneak in as part of `params`\n          { srcAmount: params.priceRoute.srcAmount, slippage: undefined }),\n      destToken: 'NFT', // support any NFT,\n      destDecimals: params.priceRoute.destDecimals,\n    };\n    return buildSwapTx(fillParams, options, requestParams);\n  };\n\n  return {\n    getNFTOrdersRate,\n    buildNFTOrderTx,\n    buildSwapAndNFTOrderTx,\n  };\n};\n\ntype CheckAndParseOrdersResult = Omit<CheckableOrderData, 'takerAmount'> & {\n  totalTakerAmount: bigint;\n};\n\ntype CheckableOrderData = Pick<\n  NFTOrderData,\n  'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'\n> & { taker?: NFTOrderData['taker'] };\n\nfunction checkAndParseOrders(\n  orders: CheckableOrderData[]\n): CheckAndParseOrdersResult {\n  assert(isFilledArray(orders), 'must pass at least 1 order');\n\n  const { takerAssetsSet, makerAssetsSet, totalTakerAmount } = orders.reduce<\n    Record<'takerAssetsSet' | 'makerAssetsSet', Set<string>> & {\n      totalTakerAmount: bigint;\n    }\n  >(\n    (accum, order) => {\n      accum.takerAssetsSet.add(order.takerAsset.toLowerCase());\n      accum.makerAssetsSet.add(order.makerAsset.toLowerCase());\n\n      accum.totalTakerAmount =\n        accum.totalTakerAmount + BigInt(order.takerAmount);\n      return accum;\n    },\n    {\n      takerAssetsSet: new Set(),\n      makerAssetsSet: new Set(),\n      totalTakerAmount: BigInt(0),\n    }\n  );\n\n  assert(\n    takerAssetsSet.size === 1,\n    'All orders must have the same takerAsset as destToken'\n  );\n  assert(makerAssetsSet.size === 1, 'All orders must have the same makerAsset');\n\n  const [{ maker, taker, makerAsset, takerAsset }] = orders;\n\n  return {\n    totalTakerAmount,\n    maker,\n    taker,\n    makerAsset: makerAsset.startsWith('0x')\n      ? makerAsset\n      : uintToAssetAddress(makerAsset),\n    takerAsset: takerAsset.startsWith('0x')\n      ? takerAsset\n      : uintToAssetAddress(takerAsset),\n  };\n}\n\n// extract asset address from makerAsset or takerAsset packed number encoded to contain AssetType\nfunction uintToAssetAddress(assetUint: BigIntAsString): Address {\n  return (\n    '0x' +\n    (BigInt(assetUint) & ((BigInt(1) << BigInt(160)) - BigInt(1))).toString(16)\n  );\n}\n","import type { ExtraFetchParams, FetcherFunction } from '../../types';\nimport type { AxiosStatic } from 'axios';\nimport { FetcherError } from '../misc';\n\nexport type AxiosRequirement = Pick<AxiosStatic, 'request' | 'isAxiosError'>;\n\nexport const constructFetcher =\n  (axios: AxiosRequirement, extra?: ExtraFetchParams): FetcherFunction =>\n  async (params) => {\n    try {\n      const { requestParams, ...rest } = params;\n      // adding apiKey to headers if it's provided\n      const headers = extra?.apiKey\n        ? {\n            'X-API-KEY': extra.apiKey,\n            ...rest.headers,\n            ...requestParams?.headers,\n          }\n        : { ...rest.headers, ...requestParams?.headers };\n\n      const allParams = { ...rest, ...requestParams, headers };\n\n      const { data } = await axios.request(allParams);\n\n      return data;\n    } catch (error: any) {\n      if (axios.isAxiosError(error)) {\n        // attach a more meaningful message and other props\n        throw new FetcherError(error);\n      }\n\n      throw error;\n    }\n  };\n","import type { ExtraFetchParams, FetcherFunction } from '../../types';\nimport { FetcherError } from '../misc';\n\n// @TODO may not work with node-fetch\ntype Fetch = typeof fetch;\n\nexport const constructFetcher =\n  (fetch: Fetch, extra?: ExtraFetchParams): FetcherFunction =>\n  async (params) => {\n    try {\n      const { url, method, requestParams } = params;\n      const body = method === 'POST' ? JSON.stringify(params.data) : null;\n      // Only JSON response for POST requests\n      const POSTheaders =\n        method === 'POST' && body\n          ? {\n              'Content-Type': 'application/json',\n            }\n          : undefined;\n\n      // adding apiKey to headers if it's provided\n      const apiHeaders = extra?.apiKey\n        ? { 'X-API-KEY': extra.apiKey }\n        : undefined;\n\n      // all headers combined\n      const headers =\n        POSTheaders || apiHeaders || params.headers || requestParams?.headers\n          ? {\n              ...apiHeaders,\n              ...POSTheaders,\n              ...params.headers,\n              ...requestParams?.headers,\n            }\n          : undefined;\n\n      const response = await fetch(url, {\n        method,\n        body,\n        ...requestParams,\n        headers,\n      });\n\n      const data = await response.json();\n\n      if (!response.ok) {\n        // @TODO figure out if this works analogous to AxiosError, especially code ==? status\n        throw new FetcherError({\n          code: String(response.status),\n          response: {\n            data,\n            status: response.status,\n            statusText: response.statusText,\n            headers: Object.fromEntries(response.headers.entries()),\n            config: { url, method },\n          },\n          message: response.statusText,\n          isAxiosError: false,\n        });\n      }\n\n      return data;\n    } catch (error: any) {\n      if (error instanceof FetcherError) throw error;\n      throw new FetcherError(error);\n    }\n  };\n","import type {\n  Address,\n  ContractCallerFunctions,\n  NoExtraKeysCheck,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport type {\n  JsonRpcProvider,\n  BaseProvider,\n  JsonRpcSigner,\n} from '@ethersproject/providers';\nimport type { Signer } from '@ethersproject/abstract-signer';\nimport type {\n  Contract as EthersV5Contract,\n  ContractFunction as EthersContractFunctionV5,\n  PopulatedTransaction as EthersPopulatedTransactionV5,\n  PayableOverrides,\n  CallOverrides,\n  ContractTransaction,\n} from '@ethersproject/contracts';\n\nimport type { BigNumber as EthersBigNumberV5 } from '@ethersproject/bignumber';\n\nimport { assert } from 'ts-essentials';\n\nexport interface EthersV5ProviderDeps {\n  ethersProviderOrSigner: BaseProvider | Signer;\n  EthersContract: typeof EthersV5Contract; // passing Contract in allows not to include ethers as dependency even when using legacy ParaSwap class\n}\n\nexport const constructEthersV5ContractCaller = (\n  {\n    ethersProviderOrSigner: providerOrSigner,\n    EthersContract: Contract,\n  }: EthersV5ProviderDeps,\n  account?: Address\n): ContractCallerFunctions<ContractTransaction> => {\n  const staticCall: StaticContractCallerFn = async (params) => {\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new Contract(address, abi, providerOrSigner);\n\n    assertEthersContractHasMethodsV5(contract, contractMethod);\n    // drop keys not in CallOverrides\n    const { block, gas, ...restOverrides } = overrides;\n    // reassign values to keys in CallOverrides\n    const normalizedOverrides = {\n      ...restOverrides,\n      blockTag: block,\n      gasLimit: gas,\n    };\n\n    // type FinalCallOverrides = normalizedOverrides has extra props ? never : normalizedOverrides\n    type FinalCallOverrides = NoExtraKeysCheck<\n      typeof normalizedOverrides,\n      CallOverrides\n    >;\n\n    // enforce overrides shape ethers accepts\n    // TS will break if normalizedOverrides type has any keys not also present in CallOverrides\n    const callOverrides: FinalCallOverrides = normalizedOverrides;\n    // returns whatever the Contract.method returns: BigNumber, string, boolean\n    return contract.callStatic[contractMethod](...args, callOverrides);\n  };\n\n  const transactCall: TransactionContractCallerFn<ContractTransaction> = async (\n    params\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    const contract = new Contract(address, abi, signer);\n\n    assertEthersContractHasMethodsV5(contract, contractMethod);\n    // drop keys not in PayableOverrides\n    const { gas, from, ...restOverrides } = overrides;\n    // reassign values to keys in PayableOverrides\n    const normalizedOverrides = {\n      ...restOverrides,\n      gasLimit: gas,\n    };\n\n    // type FinalPayableOverrides = normalizedOverrides has extra props ? never : normalizedOverrides\n    type FinalPayableOverrides = NoExtraKeysCheck<\n      typeof normalizedOverrides,\n      PayableOverrides\n    >;\n\n    // enforce overrides shape ethers accepts\n    // TS will break if normalizedOverrides type has any keys not also present in PayableOverrides\n    const txOverrides: FinalPayableOverrides = normalizedOverrides;\n    const txResponse: ContractTransaction = await contract[contractMethod](\n      ...args,\n      txOverrides\n    );\n\n    return txResponse;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    assert(isTypedDataCapableSigner(signer), 'Signer can sign typed data');\n\n    const { data, domain, types } = typedData;\n\n    return signer._signTypedData(domain, types, data);\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\nfunction isEthersProvider(\n  providerOrSigner: BaseProvider | Signer\n): providerOrSigner is BaseProvider {\n  return '_isProvider' in providerOrSigner && providerOrSigner._isProvider;\n}\n\nfunction isEthersProviderWithSigner(\n  providerOrSigner: JsonRpcProvider | BaseProvider | Signer\n): providerOrSigner is JsonRpcProvider {\n  return isEthersProvider(providerOrSigner) && 'getSigner' in providerOrSigner;\n}\n\nfunction isEthersSigner(\n  providerOrSigner: BaseProvider | Signer\n): providerOrSigner is Signer {\n  return '_isSigner' in providerOrSigner && providerOrSigner._isSigner;\n}\n\nfunction isTypedDataCapableSigner(\n  signer: Signer\n): signer is Signer & Pick<JsonRpcSigner, '_signTypedData'> {\n  return '_signTypedData' in signer;\n}\n\n/// ethers v5\ntype EthersContractWithMethodV5<T extends string> = EthersV5Contract & {\n  readonly [method in T]: EthersContractFunctionV5;\n} & {\n  readonly functions: { [method in T]: EthersContractFunctionV5 };\n\n  readonly callStatic: { [method in T]: EthersContractFunctionV5 };\n  readonly estimateGas: {\n    [method in T]: EthersContractFunctionV5<EthersBigNumberV5>;\n  };\n  readonly populateTransaction: {\n    [method in T]: EthersContractFunctionV5<EthersPopulatedTransactionV5>;\n  };\n};\n\nfunction ethersContractHasMethodsV5<T extends string>(\n  contract: EthersV5Contract,\n  ...methods: T[]\n): contract is EthersContractWithMethodV5<T> {\n  return methods.every((method) => typeof contract[method] === 'function');\n}\n\nfunction assertEthersContractHasMethodsV5<T extends string>(\n  contract: EthersV5Contract,\n  ...methods: T[]\n): asserts contract is EthersContractWithMethodV5<T> {\n  assert(\n    ethersContractHasMethodsV5(contract, ...methods),\n    `Contract must have methods: ${methods.join(', ')}`\n  );\n}\n","import type {\n  Address,\n  ContractCallerFunctions,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport { assert } from 'ts-essentials';\nimport type {\n  JsonRpcProvider,\n  Signer,\n  ContractRunner,\n  Contract as EthersContract,\n  Overrides,\n  ContractTransactionResponse,\n} from 'ethers';\n\nexport interface EthersV6ProviderDeps {\n  ethersV6ProviderOrSigner: ContractRunner | Signer;\n  EthersV6Contract: typeof EthersContract; // passing Contract in allows not to include ethers as dependency even when using legacy ParaSwap class\n}\n\nexport const constructContractCaller = (\n  {\n    ethersV6ProviderOrSigner: providerOrSigner,\n    EthersV6Contract: Contract,\n  }: EthersV6ProviderDeps,\n  account?: Address\n): ContractCallerFunctions<ContractTransactionResponse> => {\n  const staticCall: StaticContractCallerFn = async (params) => {\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new Contract(address, abi, providerOrSigner);\n\n    // drop keys not in CallOverrides\n    const { block, gas, ...restOverrides } = overrides;\n    // reassign values to keys in CallOverrides\n    const normalizedOverrides: Overrides = {\n      ...restOverrides,\n      blockTag: block,\n      gasLimit: gas,\n    };\n\n    const callableContractFunction = contract.getFunction(contractMethod);\n\n    // returns whatever the Contract[\"method\"].staticCall returns: BigNumber, string, boolean\n    return callableContractFunction.staticCall(...args, normalizedOverrides);\n  };\n\n  const transactCall: TransactionContractCallerFn<\n    ContractTransactionResponse\n  > = async (params) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? await providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    const contract = new Contract(address, abi, signer);\n\n    // drop keys not in PayableOverrides\n    const { gas, from, ...restOverrides } = overrides;\n    // reassign values to keys in PayableOverrides\n    const normalizedOverrides: Overrides = {\n      ...restOverrides,\n      gasLimit: gas,\n    };\n\n    // if no method for contractMethod, ethers will throw\n    const callableContractFunction = contract.getFunction(contractMethod);\n\n    const txResponse = await callableContractFunction.send(\n      ...args,\n      normalizedOverrides\n    );\n\n    return txResponse;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      isEthersProviderWithSigner(providerOrSigner) ||\n        isEthersSigner(providerOrSigner),\n      'ethers must be an instance of Signer or JsonRpcProvider to create a signer'\n    );\n\n    const signer =\n      'getSigner' in providerOrSigner\n        ? await providerOrSigner.getSigner(account)\n        : providerOrSigner;\n\n    const { data, domain, types } = typedData;\n\n    return signer.signTypedData(domain, types, data);\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\nfunction isEthersProviderWithSigner(\n  providerOrSigner: JsonRpcProvider | ContractRunner | Signer\n): providerOrSigner is JsonRpcProvider {\n  return 'getSigner' in providerOrSigner;\n}\n\nfunction isEthersSigner(\n  providerOrSigner: ContractRunner | Signer\n): providerOrSigner is Signer {\n  return 'getAddress' in providerOrSigner;\n}\n","import { assert } from 'ts-essentials';\nimport { TypedDataField } from '../../methods/common/orders/buildOrderData';\n\n// regex from @ethersproject/hash TypedDataEncoder.constructor\n// may be overly strict, but reliable\nconst baseTypeRegex = /^([^\\x5b]*)(\\x5b|$)/;\n\nexport function findPrimaryType(\n  types: Record<string, TypedDataField[]>\n): string {\n  const candidates = Object.keys(types);\n  const candidatesSet = new Set(candidates);\n\n  candidates.forEach((candidate) => {\n    const typedDataFields = types[candidate];\n    if (!typedDataFields) return;\n\n    typedDataFields.forEach(({ type }) => {\n      // Get the base type (drop any array specifiers)\n      const baseType = type.match(baseTypeRegex)?.[1];\n      if (!baseType) return;\n\n      // if type was referred to as a child of another type, it can't be the primaryType\n      candidatesSet.delete(baseType);\n    });\n  });\n\n  const [primaryType] = Array.from(candidatesSet);\n\n  assert(\n    primaryType,\n    `No primary type found in SignableTypedData types, ${JSON.stringify(types)}`\n  );\n\n  return primaryType;\n}\n","import type {\n  Address,\n  ContractCallerFunctions,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport type { PayableCallOptions, AbiItem } from 'web3';\nimport type Web3 from 'web3';\nimport type { ContractAbi, Contract as Web3Contract } from 'web3';\nimport type { PayableTxOptions } from 'web3-eth-contract';\nimport { assert } from 'ts-essentials';\nimport { findPrimaryType } from './helpers';\n\ntype ContractMethodRes = ReturnType<Web3ContractSendMethod>;\nexport type Web3UnpromiEvent = Pick<\n  ReturnType<ContractMethodRes['send']>,\n  'on' | 'once'\n>;\n\ntype SendOptions = PayableTxOptions;\ntype CallOptions = PayableCallOptions;\n\nexport const constructContractCaller = (\n  web3: Web3,\n  account?: Address\n): ContractCallerFunctions<Web3UnpromiEvent> => {\n  const staticCall: StaticContractCallerFn = async (params) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new web3.eth.Contract(\n      abi as AbiItem[], // FIXME abi types ethers dependant\n      address\n    );\n\n    assertWeb3ContractHasMethods(contract, contractMethod);\n\n    const { block, gas, value, ...restOverrides } = overrides;\n\n    const normalizedOverrides: CallOptions = {\n      ...restOverrides,\n      gas: gas?.toString(10),\n      value: value?.toString(10),\n    };\n\n    return contract.methods[contractMethod](...args).call(normalizedOverrides);\n  };\n\n  const transactCall: TransactionContractCallerFn<Web3UnpromiEvent> = async (\n    params\n  ) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    assert(account, 'account must be specified to send transactions');\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const contract = new web3.eth.Contract(\n      abi as unknown as AbiItem[], // FIXME\n      address\n    );\n\n    assertWeb3ContractHasMethods(contract, contractMethod);\n\n    const { gas, from, value, nonce, ...restOverrides } = overrides;\n\n    const _from = from || account;\n\n    assert(_from, 'from is required');\n\n    const normalizedOverrides: SendOptions = {\n      ...restOverrides,\n      from: _from,\n      gas: gas?.toString(10),\n      value: value?.toString(10),\n      nonce: nonce?.toString(10),\n    };\n\n    const preparedCall = contract.methods[contractMethod](...args);\n\n    const promiEvent = preparedCall.send(normalizedOverrides);\n\n    // can't just return promiEvent, because async function returns a Promise<PromiEvent>\n    // and await Promise<PromiEvent> automatically awaits the value of PromiEvent,\n    // that is await Promise<PromiEvent> = Awaited<PromiEvent> that doesn't have .on|once\n    // so that functionality becomes lost\n    // transactCall can be made sync, but approve has to be async to await getSpender()\n    const unpromiEvent: Web3UnpromiEvent = {\n      on: promiEvent.on.bind(promiEvent),\n      once: promiEvent.once.bind(promiEvent),\n    };\n\n    return unpromiEvent;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(web3.currentProvider, 'web3.currentProvider is not set');\n\n    assert(account, 'account must be specified to sign data');\n\n    const { data, domain, types } = typedData;\n\n    const _typedData = {\n      types: {\n        EIP712Domain: [\n          { name: 'name', type: 'string' },\n          { name: 'version', type: 'string' },\n          { name: 'chainId', type: 'uint256' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        ...types,\n      },\n      primaryType: findPrimaryType(types),\n      domain,\n      message: data,\n    };\n\n    // account must be among unlocked accounts\n    const signature = await web3.eth.signTypedData(account, _typedData as any);\n    return signature;\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\n/// web3@4\ntype Web3ContractSendMethod = Web3Contract<ContractAbi>['methods'][string];\n\ntype Web3ContractWithMethod<T extends string> = Web3Contract<ContractAbi> & {\n  methods: { [method in T]: Web3ContractSendMethod };\n};\n\nfunction web3ContractHasMethods<T extends string>(\n  contract: Web3Contract<ContractAbi>,\n  ...methods: T[]\n): contract is Web3ContractWithMethod<T> {\n  return methods.every(\n    (method) => typeof contract.methods[method] === 'function'\n  );\n}\n\nfunction assertWeb3ContractHasMethods<T extends string>(\n  contract: Web3Contract<ContractAbi>,\n  ...methods: T[]\n): asserts contract is Web3ContractWithMethod<T> {\n  assert(\n    web3ContractHasMethods(contract, ...methods),\n    `Contract must have methods: ${methods.join(', ')}`\n  );\n}\n","import type {\n  Address,\n  ContractCallerFunctions,\n  ContractCallStaticInput,\n  SignTypedDataContractCallerFn,\n  StaticContractCallerFn,\n  TransactionContractCallerFn,\n} from '../../types';\nimport { assert, MarkOptional } from 'ts-essentials';\n\nimport type {\n  PublicActions,\n  WalletActions,\n  Hex,\n  BlockTag,\n  Chain,\n  Transport,\n  TypedDataDomain,\n  Account,\n} from 'viem';\nimport { findPrimaryType } from './helpers';\nimport { TransactionParams } from '../../methods/swap/transaction';\n\nexport type MinViemClient = Partial<\n  Pick<PublicActions<Transport, Chain>, 'readContract'> &\n    Pick<WalletActions<Chain>, 'writeContract' | 'signTypedData'>\n> & { account?: Account };\n\nexport const constructContractCaller = (\n  viemClient: MinViemClient,\n  account?: Address\n): ContractCallerFunctions<Hex> => {\n  const staticCall: StaticContractCallerFn = async <\n    T,\n    M extends string = string\n  >(\n    params: ContractCallStaticInput<M>\n  ): Promise<T> => {\n    assert(\n      viemClient.readContract,\n      'Viem client must have readContract Public Action'\n    );\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const { block } = overrides;\n\n    const { blockNumber, blockTag } =\n      typeof block === 'number'\n        ? { blockNumber: BigInt(block) }\n        : { blockTag: block as BlockTag };\n\n    const result = viemClient.readContract({\n      account: viemClient.account || (account as Hex),\n      address: address as Hex,\n      abi,\n      functionName: contractMethod,\n      args,\n      blockTag,\n      blockNumber,\n    });\n\n    return result as T; // can't get specific type for generic abi & method\n  };\n\n  const transactCall: TransactionContractCallerFn<Hex> = async (params) => {\n    assert(account, 'account must be specified sign transactions');\n    assert(\n      viemClient.writeContract,\n      'Viem client must have writeContract Wallet Action'\n    );\n\n    const { address, abi, contractMethod, args, overrides } = params;\n\n    const viemTxParams = txParamsToViemTxParams({\n      ...overrides,\n      to: address,\n      gas: overrides.gas?.toString(10),\n      value: overrides.value?.toString(10),\n    });\n\n    const gasPriceParams =\n      'maxFeePerGas' in viemTxParams\n        ? {\n            maxFeePerGas: viemTxParams.maxFeePerGas,\n            maxPriorityFeePerGas: viemTxParams.maxPriorityFeePerGas,\n          }\n        : 'gasPrice' in viemTxParams\n        ? { gasPrice: viemTxParams.gasPrice }\n        : {};\n\n    const txHash = await viemClient.writeContract({\n      // either `viemClient` has account assigned to it,\n      // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account);\n      // otherwise breaks with ` ProviderError: Unknown account 0x...`\n      account: viemClient.account || (account as Hex),\n      address: address as Hex,\n      abi,\n      functionName: contractMethod,\n      args: argsToViemArgs(args),\n      value: viemTxParams.value,\n      gas: viemTxParams.gas,\n      // ...viemTxParams,\n      // account: (overrides.from || account) as Hex,\n      nonce: overrides.nonce,\n      ...gasPriceParams,\n    });\n\n    return txHash;\n  };\n\n  const signTypedDataCall: SignTypedDataContractCallerFn = async (\n    typedData\n  ) => {\n    assert(account, 'account must be specified to create a signer');\n    assert(\n      viemClient.signTypedData,\n      'Viem client must have signTypedData Wallet Action'\n    );\n\n    const { data, domain, types } = typedData;\n\n    const primaryType = findPrimaryType(types);\n\n    const chainId =\n      domain.chainId === undefined ? undefined : Number(domain.chainId);\n    const viemDomain: TypedDataDomain = {\n      chainId,\n      name: domain.name,\n      version: domain.version,\n      verifyingContract: domain.verifyingContract as Hex,\n      salt: domain.salt as Hex,\n    };\n\n    const signature = await viemClient.signTypedData({\n      // either `viemClient` has account assigned to it,\n      // or the provider `viemClient` was created with must control `account` (viemClient.getAddresses()[0]===account)\n      account: viemClient.account || (account as Hex),\n      domain: viemDomain,\n      types,\n      primaryType,\n      message: data,\n    });\n\n    return signature;\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n};\n\ntype ViemTxParams = {\n  to: Hex;\n  data?: Hex;\n  value?: bigint;\n  nonce?: number;\n  gas?: bigint;\n} & (\n  | { maxFeePerGas?: bigint; maxPriorityFeePerGas?: bigint }\n  | { gasPrice?: bigint }\n);\n\nexport function txParamsToViemTxParams(\n  txParams: Omit<\n    MarkOptional<TransactionParams, 'data' | 'value'>,\n    'chainId' | 'from'\n  >\n): ViemTxParams {\n  const gas = txParams.gas !== undefined ? BigInt(txParams.gas) : undefined;\n  const gasPrice =\n    txParams.gasPrice !== undefined ? BigInt(txParams.gasPrice) : undefined;\n  const maxFeePerGas =\n    txParams.maxFeePerGas !== undefined\n      ? BigInt(txParams.maxFeePerGas)\n      : undefined;\n  const maxPriorityFeePerGas =\n    txParams.maxPriorityFeePerGas !== undefined\n      ? BigInt(txParams.maxPriorityFeePerGas)\n      : undefined;\n\n  const viemTxParams = {\n    to: txParams.to as Hex,\n    data: txParams.data as Hex,\n    value: txParams.value !== undefined ? BigInt(txParams.value) : undefined,\n    gas,\n    ...(txParams.maxFeePerGas !== undefined\n      ? { maxFeePerGas, maxPriorityFeePerGas }\n      : { gasPrice }),\n  };\n  return viemTxParams;\n}\n\nfunction argsToViemArgs(args: any[]): any[] {\n  return args.map((arg) => {\n    if (typeof arg === 'string') {\n      if (arg.startsWith('0x')) {\n        return arg;\n      }\n      const asNumber = Number(arg);\n      if (Number.isNaN(asNumber)) {\n        return arg;\n      }\n      return BigInt(asNumber);\n    }\n    return arg;\n  });\n}\n","import type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\nimport { constructGetSpender } from '../swap/spender';\n\ntype GetDeltaContract = (\n  requestParams?: RequestParameters\n) => Promise<Address | null>;\nexport type GetDeltaContractFunctions = {\n  /** @description returns ParaswapDelta contract address when Delta is available on current chain */\n  getDeltaContract: GetDeltaContract;\n};\n\nexport const constructGetDeltaContract = (\n  options: ConstructFetchInput\n): GetDeltaContractFunctions => {\n  // analogous to getSpender() but for Delta Orders Contract = ParaswapDelta\n\n  const { getContracts } = constructGetSpender(options);\n\n  const getDeltaContract: GetDeltaContract = async (requestParams) => {\n    const { ParaswapDelta } = await getContracts(requestParams);\n    return ParaswapDelta || null;\n  };\n\n  return { getDeltaContract };\n};\n","import { API_URL } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\n\nexport type PartnerFeeResponse = {\n  partnerFee: number; // in %, e.g. 0.12\n  partnerAddress: string;\n  takeSurplus: boolean;\n};\n\ntype PartnerFeeQueryParams = {\n  partner: string;\n};\n\ntype GetPartnerFee = (\n  options: PartnerFeeQueryParams,\n  requestParams?: RequestParameters\n) => Promise<PartnerFeeResponse>;\n\nexport type GetPartnerFeeFunctions = {\n  getPartnerFee: GetPartnerFee;\n};\n\nexport const constructGetPartnerFee = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetPartnerFeeFunctions => {\n  const partnerFeeUrl = `${apiURL}/prices/partnerfee/${chainId}` as const;\n\n  // going on the assumption that one `partner` will correspond to one `partnerFee` during the lifetime of SDK instance,\n  // to avoid unnecessary network requests\n  const cachedPartnerFee = new Map<string, PartnerFeeResponse>();\n\n  const getPartnerFee: GetPartnerFee = async (options, requestParams) => {\n    if (cachedPartnerFee.has(options.partner)) {\n      return cachedPartnerFee.get(options.partner)!;\n    }\n\n    const search = constructSearchString<PartnerFeeQueryParams>(options);\n\n    const fetchURL = `${partnerFeeUrl}/${search}` as const;\n\n    const data = await fetcher<PartnerFeeResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    cachedPartnerFee.set(options.partner, data);\n\n    return data;\n  };\n\n  return {\n    getPartnerFee,\n  };\n};\n","import { DeltaAuctionOrder } from './types';\n\ntype DeltaOrderPermitInput = Pick<DeltaAuctionOrder, 'permit' | 'nonce'>;\n\nexport function composeDeltaOrderPermit({\n  permit,\n  nonce,\n}: DeltaOrderPermitInput): string {\n  // Can be empty Permit if allowance is available for srcToken\n  if (permit === '0x' || permit === '0x01') {\n    // 0x01 is a special permit value that signifies existing Permit2 allowance.\n    return permit;\n  }\n\n  // In the Contract, specifically for Permit2 transferFrom, we have signature consisting of\n  // bytes32(permit2nonce) + bytes64(compacted signature) = bytes96 Permit2 Transfer format\n\n  if (permit.length >= 194) {\n    // \"0x\".length + 96bytes*2 = 194, means permit already concatenated with nonce\n    // or it's a different type of Permit all together\n    return permit;\n  }\n\n  return encodePermit2Transfer(BigInt(nonce), permit);\n}\n\nfunction uintTo32ByteArrayBuffer(nonce: number | bigint) {\n  // Create a 32-byte ArrayBuffer\n  const buffer = new Uint8Array(32);\n\n  // Convert nonce to hex string and pad it to 64 hex characters (32 bytes)\n  let nonceHex = nonce.toString(16).padStart(64, '0');\n\n  // Convert the hex string to bytes and fill the ArrayBuffer\n  for (let i = 0; i < 32; i++) {\n    buffer[i] = parseInt(nonceHex.slice(i * 2, i * 2 + 2), 16);\n  }\n\n  return buffer;\n}\n\nfunction hexToByteArray(hexString: string) {\n  // Remove \"0x\" prefix if present\n  hexString = hexString.replace(/^0x/, '');\n\n  // Convert hex string to Uint8Array\n  const byteArray = new Uint8Array(hexString.length / 2);\n  for (let i = 0; i < hexString.length; i += 2) {\n    byteArray[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  return byteArray;\n}\n\nfunction encodePermit2Transfer(nonce: number | bigint, signature: string) {\n  // Get 32-byte ArrayBuffer for nonce\n  const nonceBuffer = uintTo32ByteArrayBuffer(nonce);\n\n  // Convert signature hex string to Uint8Array (64 bytes)\n  const signatureBuffer = hexToByteArray(signature);\n  if (signatureBuffer.length !== 64) {\n    throw new Error('Signature must be exactly 64 bytes');\n  }\n\n  // Concatenate nonceBuffer and signatureBuffer\n  const packedBuffer = new Uint8Array(32 + 64);\n  packedBuffer.set(nonceBuffer, 0); // Copy nonceBuffer at the start\n  packedBuffer.set(signatureBuffer, 32); // Copy signatureBuffer after nonce\n\n  // Convert to hex string for output\n  return (\n    '0x' +\n    Array.from(packedBuffer)\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('')\n  );\n}\n","import { MarkOptional } from 'ts-essentials';\nimport { Domain, ZERO_ADDRESS } from '../../common/orders/buildOrderData';\nimport { BridgeInput, DeltaAuctionOrder } from './types';\nimport { composeDeltaOrderPermit } from './composePermit';\n\n// Order(address owner,address beneficiary,address srcToken,address destToken,uint256 srcAmount,uint256 destAmount,uint256 deadline,uint256 nonce,bytes permit, bridge Bridge)\";\nconst SWAP_ORDER_EIP_712_TYPES = {\n  Order: [\n    { name: 'owner', type: 'address' },\n    { name: 'beneficiary', type: 'address' },\n    { name: 'srcToken', type: 'address' },\n    { name: 'destToken', type: 'address' },\n    { name: 'srcAmount', type: 'uint256' },\n    { name: 'destAmount', type: 'uint256' },\n    { name: 'expectedDestAmount', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'partnerAndFee', type: 'uint256' },\n    { name: 'permit', type: 'bytes' },\n    { name: 'bridge', type: 'Bridge' },\n  ],\n  Bridge: [\n    { name: 'maxRelayerFee', type: 'uint256' },\n    { name: 'destinationChainId', type: 'uint256' },\n    { name: 'outputToken', type: 'address' },\n    { name: 'multiCallHandler', type: 'address' },\n  ],\n};\n\nexport type SignableDeltaOrderData = {\n  types: {\n    Order: typeof SWAP_ORDER_EIP_712_TYPES.Order;\n    Bridge: typeof SWAP_ORDER_EIP_712_TYPES.Bridge;\n  };\n  domain: Domain;\n  data: DeltaAuctionOrder;\n};\n\ntype SignDeltaOrderInput = {\n  orderInput: DeltaAuctionOrder;\n  paraswapDeltaAddress: string;\n  chainId: number;\n};\n\nfunction produceDeltaOrderTypedData({\n  orderInput,\n  chainId,\n  paraswapDeltaAddress,\n}: SignDeltaOrderInput): SignableDeltaOrderData {\n  const typedData = {\n    types: {\n      Order: SWAP_ORDER_EIP_712_TYPES.Order,\n      Bridge: SWAP_ORDER_EIP_712_TYPES.Bridge,\n    },\n    domain: {\n      name: 'Portikus',\n      version: '2.0.0',\n      chainId,\n      verifyingContract: paraswapDeltaAddress,\n    },\n    data: orderInput,\n  };\n\n  return typedData;\n}\n\nexport type DeltaOrderDataInput = MarkOptional<\n  Omit<DeltaAuctionOrder, 'partnerAndFee'>,\n  'beneficiary' | 'deadline' | 'nonce' | 'permit'\n>;\n\nexport type BuildDeltaOrderDataInput = DeltaOrderDataInput & {\n  partnerAddress: string;\n  paraswapDeltaAddress: string;\n  partnerFeeBps: number;\n  partnerTakesSurplus?: boolean;\n  chainId: number;\n  bridge: BridgeInput;\n};\n\n// default deadline = 1 hour from now (may be changed later)\nexport const DELTA_DEFAULT_EXPIRY = 60 * 60; // seconds\n\nexport function buildDeltaSignableOrderData({\n  owner,\n  beneficiary = owner,\n\n  srcToken,\n  destToken,\n  srcAmount,\n  destAmount,\n  expectedDestAmount,\n\n  deadline = Math.floor(Date.now() / 1000 + DELTA_DEFAULT_EXPIRY),\n  nonce = Date.now().toString(10), // random enough to not cause collisions\n\n  permit = '0x',\n\n  partnerAddress,\n  partnerFeeBps,\n  partnerTakesSurplus = false,\n\n  chainId,\n  paraswapDeltaAddress,\n  bridge,\n}: BuildDeltaOrderDataInput): SignableDeltaOrderData {\n  const orderInput: DeltaAuctionOrder = {\n    owner,\n    beneficiary,\n    srcToken,\n    destToken,\n    srcAmount,\n    destAmount,\n    expectedDestAmount,\n    deadline,\n    nonce,\n    permit: composeDeltaOrderPermit({ permit, nonce }),\n    partnerAndFee: producePartnerAndFee({\n      partnerFeeBps,\n      partnerAddress,\n      partnerTakesSurplus,\n    }),\n    bridge,\n  };\n\n  return produceDeltaOrderTypedData({\n    orderInput,\n    chainId,\n    paraswapDeltaAddress,\n  });\n}\n\ntype ProducePartnerAndFeeInput = {\n  partnerFeeBps: number;\n  partnerAddress: string;\n  partnerTakesSurplus: boolean;\n};\n\n// fee and address are encoded together\nfunction producePartnerAndFee({\n  partnerFeeBps,\n  partnerAddress,\n  partnerTakesSurplus,\n}: ProducePartnerAndFeeInput): string {\n  if (partnerAddress === ZERO_ADDRESS) return '0';\n\n  const partnerAndFee =\n    (BigInt(partnerAddress) << BigInt(96)) |\n    BigInt(partnerFeeBps.toFixed(0)) |\n    (BigInt(partnerTakesSurplus) << BigInt(8));\n\n  return partnerAndFee.toString(10);\n}\n","import type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { ZERO_ADDRESS } from '../common/orders/buildOrderData';\nimport { constructGetDeltaContract } from './getDeltaContract';\nimport { DeltaPrice } from './getDeltaPrice';\nimport { constructGetPartnerFee } from './getPartnerFee';\nimport {\n  buildDeltaSignableOrderData,\n  type BuildDeltaOrderDataInput,\n  type SignableDeltaOrderData,\n} from './helpers/buildDeltaOrderData';\nimport { Bridge, BridgeInput } from './helpers/types';\nexport type { SignableDeltaOrderData } from './helpers/buildDeltaOrderData';\n\nexport type BuildDeltaOrderDataParams = {\n  /** @description The address of the order owner */\n  owner: string;\n  /** @description The address of the order beneficiary */\n  beneficiary?: string; // beneficiary==owner if no transferTo\n  /** @description The address of the src token */\n  srcToken: string; // lowercase\n  /** @description The address of the dest token */\n  destToken: string; // lowercase\n  /** @description The amount of src token to swap */\n  srcAmount: string; // wei\n  /** @description The minimum amount of dest token to receive */\n  destAmount: string; // wei, deltaPrice.destAmount - slippage\n  /** @description The deadline for the order */\n  deadline?: number; // seconds\n  /** @description The nonce of the order */\n  nonce?: number | string; // can be random, can even be Date.now()\n  /** @description Optional permit signature for the src token https://developers.paraswap.network/api/paraswap-delta/build-and-sign-a-delta-order#supported-permits */\n  permit?: string; //can be \"0x\"\n  /** @description Partner string. */\n  partner?: string;\n\n  /** @description The bridge input */\n  bridge?: BridgeInput;\n\n  /** @description price response received from /delta/prices (getDeltaPrice method) */\n  deltaPrice: Pick<DeltaPrice, 'destAmount' | 'partner' | 'partnerFee'>;\n\n  /** @description partner fee in basis points (bps), 50bps=0.5% */\n  partnerFeeBps?: number;\n  /** @description partner address */\n  partnerAddress?: string;\n  /** @description take surplus */\n  partnerTakesSurplus?: boolean;\n};\n\ntype BuildDeltaOrder = (\n  buildOrderParams: BuildDeltaOrderDataParams,\n  requestParams?: RequestParameters\n) => Promise<SignableDeltaOrderData>;\n\nexport type BuildDeltaOrderFunctions = {\n  /** @description Build Orders to be posted to Delta API for execution */\n  buildDeltaOrder: BuildDeltaOrder;\n};\n\n// for same-chain Orders, all 0 params\nconst DEFAULT_BRIDGE: Bridge = {\n  maxRelayerFee: '0',\n  destinationChainId: 0,\n  outputToken: ZERO_ADDRESS,\n  multiCallHandler: ZERO_ADDRESS,\n};\n\nexport const constructBuildDeltaOrder = (\n  options: ConstructFetchInput\n): BuildDeltaOrderFunctions => {\n  const { chainId } = options;\n\n  // cached internally\n  const { getDeltaContract } = constructGetDeltaContract(options);\n  // cached internally for `partner`\n  const { getPartnerFee } = constructGetPartnerFee(options);\n\n  const buildDeltaOrder: BuildDeltaOrder = async (options, requestParams) => {\n    const ParaswapDelta = await getDeltaContract(requestParams);\n    if (!ParaswapDelta) {\n      throw new Error(`Delta is not available on chain ${chainId}`);\n    }\n\n    // externally supplied partner fee data takes precedence\n    let partnerAddress = options.partnerAddress;\n    let partnerFeeBps =\n      options.partnerFeeBps ?? options.deltaPrice.partnerFee * 100;\n    let partnerTakesSurplus = options.partnerTakesSurplus;\n\n    // if fee given, takeSurplus is ignored\n    const feeOrTakeSurplusSupplied =\n      partnerFeeBps !== undefined || partnerTakesSurplus !== undefined;\n\n    if (partnerAddress === undefined || feeOrTakeSurplusSupplied) {\n      const partner = options.partner || options.deltaPrice.partner;\n      const partnerFeeResponse = await getPartnerFee(\n        { partner },\n        requestParams\n      );\n\n      partnerAddress = partnerAddress ?? partnerFeeResponse.partnerAddress;\n      // deltaPrice.partnerFee and partnerFeeResponse.partnerFee should be the same, but give priority to externally provided\n      partnerFeeBps = partnerFeeBps ?? partnerFeeResponse.partnerFee;\n      partnerTakesSurplus =\n        partnerTakesSurplus ?? partnerFeeResponse.takeSurplus;\n    }\n\n    const bridge: Bridge = options.bridge\n      ? {\n          ...options.bridge,\n          multiCallHandler:\n            // multicallHandler will be provided when transferring Native ETH to a Smart Contract receiver\n            // otherwise Smart Contract receiver will get WETH\n            options.bridge.multiCallHandler || DEFAULT_BRIDGE.multiCallHandler,\n        }\n      : DEFAULT_BRIDGE;\n\n    const input: BuildDeltaOrderDataInput = {\n      owner: options.owner,\n      beneficiary: options.beneficiary,\n      srcToken: options.srcToken,\n      destToken: options.destToken,\n      srcAmount: options.srcAmount,\n      destAmount: options.destAmount,\n      expectedDestAmount: options.deltaPrice.destAmount,\n      deadline: options.deadline,\n      nonce: options.nonce?.toString(10),\n      permit: options.permit,\n\n      chainId,\n      paraswapDeltaAddress: ParaswapDelta,\n      partnerAddress,\n      partnerTakesSurplus,\n      partnerFeeBps,\n\n      bridge,\n    };\n\n    return buildDeltaSignableOrderData(input);\n  };\n\n  return {\n    buildDeltaOrder,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\nimport { DeltaAuctionOrder, ParaswapDeltaAuction } from './helpers/types';\n\nexport type DeltaOrderToPost = {\n  /** @description Partner string */\n  partner?: string;\n  /** @description Referrer address */\n  referrerAddress?: string;\n  order: DeltaAuctionOrder;\n  /** @description Signature of the order from order.owner address. EOA signatures must be submitted in ERC-2098 Compact Representation. */\n  signature: string;\n  chainId: number;\n  /** @description designates the Order as being able to partilly filled, as opposed to fill-or-kill */\n  partiallyFillable?: boolean;\n};\n\nexport type PostDeltaOrderParams = Omit<DeltaOrderToPost, 'chainId'>;\n\ntype DeltaOrderApiResponse = ParaswapDeltaAuction;\n\ntype PostDeltaOrder = (\n  postData: PostDeltaOrderParams,\n  requestParams?: RequestParameters\n) => Promise<DeltaOrderApiResponse>;\n\nexport type PostDeltaOrderFunctions = {\n  postDeltaOrder: PostDeltaOrder;\n};\n\nexport const constructPostDeltaOrder = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): PostDeltaOrderFunctions => {\n  const postOrderUrl = `${apiURL}/delta/orders` as const;\n\n  const postDeltaOrder: PostDeltaOrder = (postData, requestParams) => {\n    const deltaOrderToPost: DeltaOrderToPost = { ...postData, chainId };\n\n    return fetcher<DeltaOrderApiResponse>({\n      url: postOrderUrl,\n      method: 'POST',\n      data: deltaOrderToPost,\n      requestParams,\n    });\n  };\n\n  return { postDeltaOrder };\n};\n","import type { SignableDeltaOrderData } from './buildDeltaOrderData';\n\nexport function sanitizeDeltaOrderData({\n  owner,\n  beneficiary,\n  srcToken,\n  destToken,\n  srcAmount,\n  destAmount,\n  expectedDestAmount,\n  deadline,\n  nonce,\n  permit,\n  partnerAndFee,\n  bridge,\n}: SignableDeltaOrderData['data'] &\n  Record<string, any>): SignableDeltaOrderData['data'] {\n  return {\n    owner,\n    beneficiary,\n    srcToken,\n    destToken,\n    srcAmount,\n    destAmount,\n    expectedDestAmount,\n    deadline,\n    nonce,\n    permit,\n    partnerAndFee,\n    bridge,\n  };\n}\n","// import { deriveCompactSignature } from '../../helpers/misc';\nimport type { ConstructProviderFetchInput } from '../../types';\nimport { SignableDeltaOrderData } from './helpers/buildDeltaOrderData';\nimport { sanitizeDeltaOrderData } from './helpers/misc';\n\nexport type SignLimitOrderFunctions = {\n  signLimitOrder: (\n    signableOrderData: SignableDeltaOrderData\n  ) => Promise<string>;\n};\n\ntype SignDeltaOrder = (\n  signableOrderData: SignableDeltaOrderData\n) => Promise<string>;\n\nexport type SignDeltaOrderFunctions = {\n  signDeltaOrder: SignDeltaOrder;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructSignDeltaOrder = (\n  options: Pick<\n    ConstructProviderFetchInput<any, 'signTypedDataCall'>,\n    'contractCaller'\n  >\n): SignDeltaOrderFunctions => {\n  const signDeltaOrder: SignDeltaOrder = async (typedData) => {\n    // types allow to pass OrderData & extra_stuff, but tx will break like that\n    const typedDataOnly: SignableDeltaOrderData = {\n      ...typedData,\n      data: sanitizeDeltaOrderData(typedData.data),\n    };\n    const signature = await options.contractCaller.signTypedDataCall(\n      typedDataOnly\n    );\n\n    // Safe signature with only one signer has length 132\n    // but if it is compacted, the recovered address doesn't match the signer\n\n    return signature;\n\n    // if (signature.length > 132) {\n    //   // signature more than 65 bytes, likely a multisig\n    //   // not compatible with EIP-2098 Compact Signatures\n    //   return signature;\n    // }\n\n    // // both full and compact signatures work in the ParaswapDelta contract;\n    // // compact signature can be marginally more gas efficient\n    // try {\n    //   return deriveCompactSignature(signature);\n    // } catch {\n    //   return signature;\n    // }\n  };\n\n  return { signDeltaOrder };\n};\n","import { API_URL, SwapSide } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { ConstructFetchInput, RequestParameters } from '../../types';\n\nexport type DeltaPriceParams = {\n  /** @description Source Token Address. Not Native Token */\n  srcToken: string;\n  /** @description Destination Token Address */\n  destToken: string;\n  /** @description srcToken amount in wei */\n  amount: string;\n  /** @description Source Token Decimals */\n  srcDecimals: number;\n  /** @description Destination Token Decimals */\n  destDecimals: number;\n  // side?: SwapSide; // no BUY side for now\n  /** @description User's Wallet Address */\n  userAddress?: string;\n  /** @description Partner string. */\n  partner?: string;\n  /** @description Destination Chain ID for Crosschain Orders */\n  destChainId?: number;\n};\n\ntype DeltaPriceQueryOptions = DeltaPriceParams & {\n  chainId: number; // will return error from API on unsupported chains\n  side: SwapSide.SELL;\n};\n\nexport type DeltaPrice = {\n  srcToken: string;\n  destToken: string;\n  srcAmount: string;\n  destAmount: string;\n  destAmountBeforeFee: string;\n  gasCost: string;\n  gasCostBeforeFee: string;\n  gasCostUSD: string;\n  gasCostUSDBeforeFee: string;\n  srcUSD: string;\n  destUSD: string;\n  destUSDBeforeFee: string;\n  partner: string;\n  partnerFee: number; // in %\n  hmac: string;\n};\n\nexport type BridgePrice = DeltaPrice & {\n  destTokenSrcChain: string;\n  destAmountAfterBridge: string;\n  destUSDAfterBridge: string;\n  bridgeFee: string;\n  bridgeFeeUSD: string;\n  poolAddress: string;\n};\n\ntype DeltaPriceResponse = {\n  price: DeltaPrice | BridgePrice;\n};\n\ninterface GetDeltaPrice {\n  (\n    options: DeltaPriceParams & { destChainId: number },\n    requestParams?: RequestParameters\n  ): Promise<BridgePrice>;\n  (\n    options: DeltaPriceParams & { destChainId?: undefined },\n    requestParams?: RequestParameters\n  ): Promise<DeltaPrice>;\n  (options: DeltaPriceParams, requestParams?: RequestParameters): Promise<\n    DeltaPrice | BridgePrice\n  >;\n}\n\nexport type GetDeltaPriceFunctions = {\n  getDeltaPrice: GetDeltaPrice;\n};\n\nexport const constructGetDeltaPrice = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetDeltaPriceFunctions => {\n  const pricesUrl = `${apiURL}/delta/prices` as const;\n\n  async function getDeltaPrice(\n    options: DeltaPriceParams & { destChainId: number },\n    requestParams?: RequestParameters\n  ): Promise<BridgePrice>;\n  async function getDeltaPrice(\n    options: DeltaPriceParams & { destChainId?: undefined },\n    requestParams?: RequestParameters\n  ): Promise<DeltaPrice>;\n  async function getDeltaPrice(\n    options: DeltaPriceParams,\n    requestParams?: RequestParameters\n  ): Promise<DeltaPrice | BridgePrice>;\n  async function getDeltaPrice(\n    options: DeltaPriceParams,\n    requestParams?: RequestParameters\n  ): Promise<DeltaPrice | BridgePrice> {\n    const search = constructSearchString<DeltaPriceQueryOptions>({\n      ...options,\n      chainId,\n      side: SwapSide.SELL, // so far SELL side only\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<DeltaPriceResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data.price;\n  }\n\n  return {\n    getDeltaPrice,\n  };\n};\n","import { API_URL } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\nimport type { ParaswapDeltaAuction } from './helpers/types';\n\ntype OrderFromAPI = Omit<ParaswapDeltaAuction, 'signature'>;\n\ntype GetDeltaOrderById = (\n  orderId: string,\n  requestParams?: RequestParameters\n) => Promise<OrderFromAPI>;\n\ntype GetDeltaOrderByHash = (\n  orderHash: string,\n  requestParams?: RequestParameters\n) => Promise<OrderFromAPI>;\n\ntype OrdersFilter = {\n  /** @description Order.owner to fetch Delta Order for */\n  userAddress: Address;\n  /** @description Pagination option, page. Default 1 */\n  page?: number;\n  /** @description Pagination option, limit. Default 100 */\n  limit?: number;\n};\ntype OrderFiltersQuery = OrdersFilter;\n\ntype GetDeltaOrders = (\n  options: OrdersFilter,\n  requestParams?: RequestParameters\n) => Promise<OrderFromAPI[]>;\n\nexport type GetDeltaOrdersFunctions = {\n  getDeltaOrderById: GetDeltaOrderById;\n  getDeltaOrderByHash: GetDeltaOrderByHash;\n  getDeltaOrders: GetDeltaOrders;\n};\n\nexport const constructGetDeltaOrders = ({\n  apiURL = API_URL,\n  fetcher,\n}: ConstructFetchInput): GetDeltaOrdersFunctions => {\n  const baseUrl = `${apiURL}/delta/orders` as const;\n\n  const getDeltaOrderById: GetDeltaOrderById = async (\n    orderId,\n    requestParams\n  ) => {\n    const fetchURL = `${baseUrl}/${orderId}` as const;\n\n    const order = await fetcher<OrderFromAPI>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return order;\n  };\n\n  const getDeltaOrderByHash: GetDeltaOrderByHash = async (\n    orderHash,\n    requestParams\n  ) => {\n    const fetchURL = `${baseUrl}/hash/${orderHash}` as const;\n\n    const order = await fetcher<OrderFromAPI>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return order;\n  };\n\n  const getDeltaOrders: GetDeltaOrders = async (options, requestParams) => {\n    const search = constructSearchString<OrderFiltersQuery>({\n      userAddress: options.userAddress,\n      page: options.page,\n      limit: options.limit,\n    });\n\n    const fetchURL = `${baseUrl}${search}` as const;\n\n    const orders = await fetcher<OrderFromAPI[]>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return orders;\n  };\n\n  return {\n    getDeltaOrderById,\n    getDeltaOrderByHash,\n    getDeltaOrders,\n  };\n};\n","import type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n} from '../../types';\nimport { ApproveToken, approveTokenMethodFactory } from '../../helpers/approve';\nimport { constructGetDeltaContract } from './getDeltaContract';\n\nexport type ApproveTokenForDeltaFunctions<T> = {\n  /** @description approving ParaswapDelta as spender for Token */\n  approveTokenForDelta: ApproveToken<T>;\n};\n\n// returns whatever `contractCaller` returns\n// to allow for better versatility\nexport const constructApproveTokenForDelta = <T>(\n  options: ConstructProviderFetchInput<T, 'transactCall'>\n): ApproveTokenForDeltaFunctions<T> => {\n  // getAugustusRFQ is cached internally for the same instance of SDK\n  // so should persist across same apiUrl & network\n  const { getDeltaContract } = constructGetDeltaContract(options);\n\n  const getParaswapDelta = async (requestParams?: RequestParameters) => {\n    const deltaContract = await getDeltaContract(requestParams);\n    if (!deltaContract) {\n      throw new Error(`Delta is not available on chain ${options.chainId}`);\n    }\n    return deltaContract;\n  };\n\n  const approveTokenForDelta: ApproveToken<T> = approveTokenMethodFactory<T>(\n    options.contractCaller,\n    getParaswapDelta\n  );\n\n  return {\n    approveTokenForDelta,\n  };\n};\n","import { API_URL } from '../../constants';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\n\n// srcChainId -> destChainId -> outputToken[]\n// output Tokens that are supported for a srcChainId -> destChainId pair\nexport type BridgeInfo = Record<number, Record<number, Address[]>>;\ntype BridgeInfoResponse = { supportedTokens: BridgeInfo };\n\ntype GetBridgeInfo = (requestParams?: RequestParameters) => Promise<BridgeInfo>;\n\nexport type GetBridgeInfoFunctions = {\n  getBridgeInfo: GetBridgeInfo;\n};\n\nexport const constructGetBridgeInfo = ({\n  apiURL = API_URL,\n  fetcher,\n}: ConstructFetchInput): GetBridgeInfoFunctions => {\n  const bridgeInfoUrl = `${apiURL}/delta/prices/bridge-info` as const;\n\n  const getBridgeInfo: GetBridgeInfo = async (requestParams) => {\n    const data = await fetcher<BridgeInfoResponse>({\n      url: bridgeInfoUrl,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data.supportedTokens;\n  };\n\n  return {\n    getBridgeInfo,\n  };\n};\n","import { API_URL } from '../../constants';\nimport { runOnceAndCache } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\n\n// chainId -> multicallHandler\nexport type MulticallHandlersResponse = Record<number, Address>;\n\ntype GetMulticallHandlers = (\n  requestParams?: RequestParameters\n) => Promise<MulticallHandlersResponse>;\n\nexport type GetMulticallHandlersFunctions = {\n  getMulticallHandlers: GetMulticallHandlers;\n};\n\nexport const constructGetMulticallHandlers = ({\n  apiURL = API_URL,\n  fetcher,\n}: ConstructFetchInput): GetMulticallHandlersFunctions => {\n  const multicallHandlersUrl =\n    `${apiURL}/delta/prices/multicall-handlers` as const;\n\n  const _getMulticallHandlers: GetMulticallHandlers = async (requestParams) => {\n    const data = await fetcher<MulticallHandlersResponse>({\n      url: multicallHandlersUrl,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data;\n  };\n\n  // cached for the same instance of `{getMulticallHandlers} = constructGetMulticallHandlers()`\n  // so should persist across same apiUrl & network (and response is even network agnostic)\n  const getMulticallHandlers = runOnceAndCache(_getMulticallHandlers);\n\n  return {\n    getMulticallHandlers,\n  };\n};\n","import { API_URL } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type {\n  Address,\n  ConstructFetchInput,\n  RequestParameters,\n} from '../../types';\n\ntype TokenSupportedInDeltaResponse = { supported: boolean };\ntype IsTokenSupportedInDeltaQueryOptions = {\n  token: Address;\n  chainId: number;\n};\n\ntype IsTokenSupportedInDelta = (\n  token: Address,\n  requestParams?: RequestParameters\n) => Promise<boolean>;\n\nexport type IsTokenSupportedInDeltaFunctions = {\n  isTokenSupportedInDelta: IsTokenSupportedInDelta;\n};\n\nexport const constructIsTokenSupportedInDelta = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): IsTokenSupportedInDeltaFunctions => {\n  const bridgeInfoUrl = `${apiURL}/delta/prices/is-token-supported` as const;\n\n  const isTokenSupportedInDelta: IsTokenSupportedInDelta = async (\n    token,\n    requestParams\n  ) => {\n    const search = constructSearchString<IsTokenSupportedInDeltaQueryOptions>({\n      token,\n      chainId,\n    });\n\n    const fetchURL = `${bridgeInfoUrl}/${search}` as const;\n\n    const data = await fetcher<TokenSupportedInDeltaResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data.supported;\n  };\n\n  return {\n    isTokenSupportedInDelta,\n  };\n};\n","import { API_URL, SwapSide } from '../../constants';\nimport { constructSearchString } from '../../helpers/misc';\nimport type { DeltaPrice } from '../delta/getDeltaPrice';\nimport type {\n  ConstructFetchInput,\n  EnumerateLiteral,\n  RequestParameters,\n  OptimalRate,\n} from '../../types';\n\ntype TradeMode = 'delta' | 'market' | 'all';\n// enable passing enum value by string\ntype SwapSideUnion = EnumerateLiteral<typeof SwapSide>;\n\nexport type QuoteParams<M extends TradeMode = TradeMode> = {\n  /** @description Source Token Address */\n  srcToken: string;\n  /** @description Destination Token Address */\n  destToken: string;\n  /** @description srcToken amount (in case of SELL) or destToken amount (in case of BUY), in wei */\n  amount: string;\n  /** @description Source Token Decimals.  */\n  srcDecimals: number;\n  /** @description Destination Token Decimals */\n  destDecimals: number;\n  /** @description SELL or BUY */\n  side: SwapSideUnion;\n  /** @description User's Wallet Address */\n  userAddress?: string;\n  /** @description Partner string */\n  partner?: string;\n  /** @description Preferred mode for the trade. In case of \"all\", Delta pricing is returned, with Market as a fallback */\n  mode: M;\n};\n\ntype QuoteQueryOptions = QuoteParams & {\n  chainId: number; // will return error from API on unsupported chains\n};\n\ntype FallbackReason = {\n  errorType: string;\n  details: string;\n};\n\nexport type QuoteWithMarketPrice = {\n  market: OptimalRate;\n};\n\nexport type QuoteWithDeltaPrice = {\n  delta: DeltaPrice;\n};\n\nexport type QuoteWithMarketPriceAsFallback = QuoteWithMarketPrice & {\n  fallbackReason: FallbackReason;\n};\n\nexport type QuoteResponse =\n  | QuoteWithDeltaPrice\n  | QuoteWithMarketPrice\n  | QuoteWithMarketPriceAsFallback;\n\ninterface GetQuoteFunc {\n  (\n    options: QuoteParams<'delta'>,\n    requestParams?: RequestParameters\n  ): Promise<QuoteWithDeltaPrice>;\n  (\n    options: QuoteParams<'market'>,\n    requestParams?: RequestParameters\n  ): Promise<QuoteWithMarketPrice>;\n  (options: QuoteParams<'all'>, requestParams?: RequestParameters): Promise<\n    QuoteWithDeltaPrice | QuoteWithMarketPriceAsFallback // \"all\" mode tries for deltaPrice and falls back to market priceRoute\n  >;\n  (\n    options: QuoteParams,\n    requestParams?: RequestParameters\n  ): Promise<QuoteResponse>;\n}\n\nexport type GetQuoteFunctions = {\n  getQuote: GetQuoteFunc;\n};\n\nexport const constructGetQuote = ({\n  apiURL = API_URL,\n  chainId,\n  fetcher,\n}: ConstructFetchInput): GetQuoteFunctions => {\n  const pricesUrl = `${apiURL}/quote` as const;\n\n  function getQuote(\n    options: QuoteParams<'delta'>,\n    requestParams?: RequestParameters\n  ): Promise<QuoteWithDeltaPrice>;\n  function getQuote(\n    options: QuoteParams<'market'>,\n    requestParams?: RequestParameters\n  ): Promise<QuoteWithMarketPrice>;\n  function getQuote(\n    options: QuoteParams<'all'>,\n    requestParams?: RequestParameters\n  ): Promise<QuoteWithDeltaPrice | QuoteWithMarketPriceAsFallback>;\n  function getQuote(\n    options: QuoteParams,\n    requestParams?: RequestParameters\n  ): Promise<QuoteResponse>;\n  async function getQuote(\n    options: QuoteParams,\n    requestParams?: RequestParameters\n  ): Promise<QuoteResponse> {\n    const search = constructSearchString<QuoteQueryOptions>({\n      ...options,\n      chainId,\n      // side: SwapSide.SELL, // so far SELL side only for Delta\n    });\n\n    const fetchURL = `${pricesUrl}/${search}` as const;\n\n    const data = await fetcher<QuoteResponse>({\n      url: fetchURL,\n      method: 'GET',\n      requestParams,\n    });\n\n    return data;\n  }\n\n  return {\n    getQuote,\n  };\n};\n","import type {\n  AnyFunction,\n  ConstructBaseInput,\n  ConstructFetchInput,\n  ConstructProviderFetchInput,\n} from '../types';\nimport type { Merge, UnionToIntersection } from 'ts-essentials';\nimport type { ApproveTokenFunctions } from '../methods/swap/approve';\nimport type { CancelLimitOrderFunctions } from '../methods/limitOrders/cancelOrder';\nimport type { ApproveTokenForLimitOrderFunctions } from '../methods/limitOrders/approveForOrder';\nimport type { CancelNFTOrderFunctions } from '../methods/nftOrders/cancelOrder';\nimport type { ApproveTokenForNFTOrderFunctions } from '../methods/nftOrders/approveForOrder';\nimport type { FillOrderDirectlyFunctions } from '../methods/limitOrders/fillOrderDirectly';\nimport type { ApproveTokenForDeltaFunctions } from '../methods/delta/approveForDelta';\nimport { API_URL, DEFAULT_VERSION } from '../constants';\n\nexport type SDKConfig<TxResponse = any> = ConstructProviderFetchInput<\n  TxResponse,\n  'staticCall' | 'transactCall' | 'signTypedDataCall'\n> &\n  ConstructFetchInput;\n\ntype SDKFunction<T extends ConstructBaseInput> = (\n  config: T\n) => Record<string, AnyFunction | Record<string, AnyFunction>>;\n\ntype IntersectionOfReturns<Funcs extends AnyFunction[]> = UnionToIntersection<\n  ReturnType<Funcs[number]>\n>;\n\ntype PartialSDKResult<\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n> = InferWithTxResponse<Config, Funcs>;\n\ntype InferWithTxResponse<\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n> = Config extends SDKConfig<infer TxResponse> // if can infer TxResponse inside Config\n  ? // and if returns can be successfully intersected\n    IntersectionOfReturns<Funcs> extends Record<string, any>\n    ? MergeExtendableRecursively<\n        IntersectionOfReturns<Funcs>,\n        [\n          // if there are ApproveTokenFunctions or CancelLimitOrderFunctions in the intersection\n          // which means constructApproveToken or constructCancelLimitOrder was passed in Funcs\n          ApproveTokenFunctions<TxResponse>,\n          CancelLimitOrderFunctions<TxResponse>,\n          FillOrderDirectlyFunctions<TxResponse>,\n          ApproveTokenForLimitOrderFunctions<TxResponse>,\n          CancelNFTOrderFunctions<TxResponse>,\n          ApproveTokenForNFTOrderFunctions<TxResponse>,\n          ApproveTokenForDeltaFunctions<TxResponse>\n        ]\n        // then merge IntersectionOfReturns<Funcs> with them recursively\n      >\n    : IntersectionOfReturns<Funcs>\n  : IntersectionOfReturns<Funcs>;\n\n// merges Accum with Replacement\n// if Accum has keys of Replacement\ntype MergeExtendableOnce<\n  Accum extends Record<string, any>,\n  Replacement extends Record<string, any>\n> = Accum extends Record<keyof Replacement, any>\n  ? Merge<Accum, Replacement>\n  : Accum;\n\n// recursively merges Accum with each Replacement\n// if Accum has keys of Replacement\ntype MergeExtendableRecursively<\n  Accum extends Record<string, any>,\n  Replacements extends Record<string, any>[]\n> = Replacements extends [\n  head: infer Head extends Record<string, any>,\n  ...tail: infer Tail\n]\n  ? Tail extends Record<string, any>[]\n    ? MergeExtendableRecursively<MergeExtendableOnce<Accum, Head>, Tail>\n    : MergeExtendableOnce<Accum, Head>\n  : Accum;\n\n/** @description construct composable SDK with methods you choose yourself */\nexport const constructPartialSDK = <\n  Config extends ConstructBaseInput,\n  Funcs extends [SDKFunction<Config>, ...SDKFunction<Config>[]]\n>(\n  config: Config, // config is auto-inferred to cover the used functions\n  ...funcs: Funcs\n): PartialSDKResult<Config, Funcs> & Required<ConstructBaseInput> => {\n  const sdkFuncs = funcs.reduce<Partial<IntersectionOfReturns<Funcs>>>(\n    (accum, func) => {\n      const sdkSlice = func(config);\n      return Object.assign(accum, sdkSlice);\n    },\n    {}\n  );\n\n  const sdk = {\n    ...sdkFuncs,\n    apiURL: config.apiURL ?? API_URL,\n    version: config.version ?? DEFAULT_VERSION,\n    chainId: config.chainId,\n  } as PartialSDKResult<Config, Funcs> & Required<ConstructBaseInput>;\n\n  return sdk;\n};\n","import { constructPartialSDK, SDKConfig } from '../../sdk/partial';\nimport { constructGetAdapters, GetAdaptersFunctions } from './adapters';\nimport { ApproveTokenFunctions, constructApproveToken } from './approve';\nimport { constructGetBalances, GetBalancesFunctions } from './balance';\nimport { constructGetRate, GetRateFunctions } from './rates';\nimport { constructGetSpender, GetSpenderFunctions } from './spender';\nimport { constructSwapTx, GetSwapTxFunctions } from './swapTx';\nimport { constructGetTokens, GetTokensFunctions } from './token';\nimport { BuildTxFunctions, constructBuildTx } from './transaction';\n\nexport type SwapSDKMethods<TxResponse> = GetBalancesFunctions &\n  GetTokensFunctions &\n  GetSpenderFunctions &\n  ApproveTokenFunctions<TxResponse> &\n  BuildTxFunctions &\n  GetAdaptersFunctions &\n  GetRateFunctions &\n  GetSwapTxFunctions;\n\n/** @description construct SDK with every Swap-related method, fetching from API and token approval */\nexport const constructSwapSDK = <TxResponse>(\n  config: SDKConfig<TxResponse>\n): SwapSDKMethods<TxResponse> => {\n  const constructApproveTokenWithTxResponse = constructApproveToken<TxResponse>;\n\n  // include all available Swap methods\n  return constructPartialSDK(\n    config,\n    constructGetBalances,\n    constructGetTokens,\n    constructGetSpender,\n    constructApproveTokenWithTxResponse,\n    constructBuildTx,\n    constructGetAdapters,\n    constructGetRate,\n    constructSwapTx\n  );\n};\n","import type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n} from '../../types';\nimport type { LimitOrderToSend, LimitOrderFromApi } from './helpers/types';\nimport {\n  BuildLimitOrderFunctions,\n  BuildLimitOrderInput,\n  constructBuildLimitOrder,\n} from './buildOrder';\nimport {\n  CancelLimitOrderFunctions,\n  constructCancelLimitOrder,\n} from './cancelOrder';\nimport { constructGetLimitOrders, GetLimitOrdersFunctions } from './getOrders';\nimport { constructPostLimitOrder, PostLimitOrderFunctions } from './postOrder';\nimport { constructSignLimitOrder, SignLimitOrderFunctions } from './signOrder';\nimport {\n  constructApproveTokenForLimitOrder,\n  ApproveTokenForLimitOrderFunctions,\n} from './approveForOrder';\nimport {\n  GetLimitOrdersContractFunctions,\n  constructGetLimitOrdersContract,\n} from './getOrdersContract';\nimport {\n  BuildLimitOrdersTxFunctions,\n  constructBuildLimitOrderTx,\n} from './transaction';\nimport type { Address } from '@paraswap/core';\nimport {\n  FillOrderDirectlyFunctions,\n  constructFillOrderDirectly,\n} from './fillOrderDirectly';\n\ntype SubmitLimitOrder = (\n  buildLimitOrderParams: BuildLimitOrderInput,\n  extra?: { permitMakerAsset?: string },\n  requestParams?: RequestParameters\n) => Promise<LimitOrderFromApi>;\n\ntype SubmitP2POrder = (\n  buildLimitOrderParams: BuildLimitOrderInput & { taker: Address },\n  extra?: { permitMakerAsset?: string },\n  requestParams?: RequestParameters\n) => Promise<LimitOrderFromApi>;\n\nexport type SubmitLimitOrderFuncs = {\n  submitLimitOrder: SubmitLimitOrder;\n  submitP2POrder: SubmitP2POrder;\n};\n\nexport const constructSubmitLimitOrder = (\n  options: ConstructProviderFetchInput<any, 'signTypedDataCall'>\n): SubmitLimitOrderFuncs => {\n  const { buildLimitOrder } = constructBuildLimitOrder(options);\n  const { signLimitOrder } = constructSignLimitOrder(options);\n  const { postLimitOrder, postP2POrder } = constructPostLimitOrder(options);\n\n  const prepareLimitOrder = async (\n    buildLimitOrderParams: BuildLimitOrderInput,\n    extra?: { permitMakerAsset?: string }\n  ): Promise<LimitOrderToSend> => {\n    const orderData = await buildLimitOrder(buildLimitOrderParams);\n    const signature = await signLimitOrder(orderData);\n\n    const orderWithSignature: LimitOrderToSend = {\n      ...orderData.data,\n      ...extra,\n      signature,\n    };\n\n    return orderWithSignature;\n  };\n\n  const submitLimitOrder: SubmitLimitOrder = async (\n    buildLimitOrderParams,\n    extra = {},\n    requestParams\n  ) => {\n    const orderWithSignature: LimitOrderToSend = await prepareLimitOrder(\n      buildLimitOrderParams,\n      extra\n    );\n\n    const newOrder = await postLimitOrder(orderWithSignature, requestParams);\n\n    return newOrder;\n  };\n\n  const submitP2POrder: SubmitP2POrder = async (\n    buildLimitOrderParams,\n    extra = {},\n    requestParams\n  ) => {\n    const orderWithSignature: LimitOrderToSend = await prepareLimitOrder(\n      buildLimitOrderParams,\n      extra\n    );\n\n    const newOrder = await postP2POrder(orderWithSignature, requestParams);\n\n    return newOrder;\n  };\n\n  return { submitLimitOrder, submitP2POrder };\n};\n\nexport type LimitOrderHandlers<T> = SubmitLimitOrderFuncs &\n  BuildLimitOrderFunctions &\n  SignLimitOrderFunctions &\n  PostLimitOrderFunctions &\n  GetLimitOrdersFunctions &\n  GetLimitOrdersContractFunctions &\n  BuildLimitOrdersTxFunctions &\n  CancelLimitOrderFunctions<T> &\n  ApproveTokenForLimitOrderFunctions<T> &\n  FillOrderDirectlyFunctions<T>;\n\n/** @description construct SDK with every LimitOrders-related method, fetching from API and contract calls */\nexport const constructAllLimitOrdersHandlers = <TxResponse>(\n  options: ConstructProviderFetchInput<\n    TxResponse,\n    'signTypedDataCall' | 'transactCall' | 'staticCall'\n  >\n): LimitOrderHandlers<TxResponse> => {\n  const limitOrdersGetters = constructGetLimitOrders(options);\n  const limitOrdersContractGetter = constructGetLimitOrdersContract(options);\n\n  const limitOrdersSubmit = constructSubmitLimitOrder(options);\n  const limitOrdersBuild = constructBuildLimitOrder(options);\n  const limitOrdersSign = constructSignLimitOrder(options);\n  const limitOrdersPost = constructPostLimitOrder(options);\n\n  const limitOrdersCancel = constructCancelLimitOrder(options);\n  const limitOrdersApproveToken = constructApproveTokenForLimitOrder(options);\n\n  const limitOrdersFillOrderDirectly = constructFillOrderDirectly(options);\n\n  const limitOrdersBuildTx = constructBuildLimitOrderTx(options);\n\n  return {\n    ...limitOrdersGetters,\n    ...limitOrdersContractGetter,\n    ...limitOrdersSubmit,\n    ...limitOrdersBuild,\n    ...limitOrdersSign,\n    ...limitOrdersPost,\n    ...limitOrdersCancel,\n    ...limitOrdersApproveToken,\n    ...limitOrdersFillOrderDirectly,\n    ...limitOrdersBuildTx,\n  };\n};\n","import type { ConstructProviderFetchInput } from '../../types';\nimport type { ParaswapDeltaAuction } from './helpers/types';\nimport {\n  BuildDeltaOrderDataParams,\n  BuildDeltaOrderFunctions,\n  constructBuildDeltaOrder,\n} from './buildDeltaOrder';\nimport {\n  constructPostDeltaOrder,\n  PostDeltaOrderFunctions,\n} from './postDeltaOrder';\nimport {\n  constructSignDeltaOrder,\n  SignDeltaOrderFunctions,\n} from './signDeltaOrder';\nimport {\n  GetDeltaContractFunctions,\n  constructGetDeltaContract,\n} from './getDeltaContract';\nimport {\n  constructGetDeltaPrice,\n  GetDeltaPriceFunctions,\n} from './getDeltaPrice';\nimport {\n  constructGetDeltaOrders,\n  GetDeltaOrdersFunctions,\n} from './getDeltaOrders';\nimport {\n  constructGetPartnerFee,\n  GetPartnerFeeFunctions,\n} from './getPartnerFee';\nimport {\n  ApproveTokenForDeltaFunctions,\n  constructApproveTokenForDelta,\n} from './approveForDelta';\nimport {\n  constructGetBridgeInfo,\n  GetBridgeInfoFunctions,\n} from './getBridgeInfo';\nimport {\n  constructGetMulticallHandlers,\n  GetMulticallHandlersFunctions,\n} from './getMulticallHandlers';\nimport {\n  constructIsTokenSupportedInDelta,\n  IsTokenSupportedInDeltaFunctions,\n} from './isTokenSupportedInDelta';\n\nexport type SubmitDeltaOrderParams = BuildDeltaOrderDataParams & {\n  /** @description designates the Order as being able to be partilly filled, as opposed to fill-or-kill */\n  partiallyFillable?: boolean;\n};\n\ntype SubmitDeltaOrder = (\n  orderParams: SubmitDeltaOrderParams\n) => Promise<ParaswapDeltaAuction>;\n\nexport type SubmitDeltaOrderFuncs = {\n  submitDeltaOrder: SubmitDeltaOrder;\n};\n\nexport const constructSubmitDeltaOrder = (\n  options: ConstructProviderFetchInput<any, 'signTypedDataCall'>\n): SubmitDeltaOrderFuncs => {\n  const { buildDeltaOrder } = constructBuildDeltaOrder(options);\n  const { signDeltaOrder } = constructSignDeltaOrder(options);\n  const { postDeltaOrder } = constructPostDeltaOrder(options);\n\n  const submitDeltaOrder: SubmitDeltaOrder = async (orderParams) => {\n    const orderData = await buildDeltaOrder(orderParams);\n    const signature = await signDeltaOrder(orderData);\n\n    const response = await postDeltaOrder({\n      signature,\n      partner: orderParams.partner,\n      order: orderData.data,\n      partiallyFillable: orderParams.partiallyFillable,\n    });\n\n    return response;\n  };\n\n  return { submitDeltaOrder };\n};\n\nexport type DeltaOrderHandlers<T> = SubmitDeltaOrderFuncs &\n  ApproveTokenForDeltaFunctions<T> &\n  BuildDeltaOrderFunctions &\n  GetDeltaOrdersFunctions &\n  GetDeltaPriceFunctions &\n  GetDeltaContractFunctions &\n  GetPartnerFeeFunctions &\n  GetMulticallHandlersFunctions &\n  GetBridgeInfoFunctions &\n  IsTokenSupportedInDeltaFunctions &\n  PostDeltaOrderFunctions &\n  SignDeltaOrderFunctions;\n\n/** @description construct SDK with every Delta Order-related method, fetching from API and Order signing */\nexport const constructAllDeltaOrdersHandlers = <TxResponse>(\n  options: ConstructProviderFetchInput<\n    TxResponse,\n    'signTypedDataCall' | 'transactCall'\n  >\n): DeltaOrderHandlers<TxResponse> => {\n  const deltaOrdersGetters = constructGetDeltaOrders(options);\n  const deltaOrdersContractGetter = constructGetDeltaContract(options);\n  const deltaPrice = constructGetDeltaPrice(options);\n\n  const partnerFee = constructGetPartnerFee(options);\n  const bridgeInfo = constructGetBridgeInfo(options);\n  const isTokenSupportedInDelta = constructIsTokenSupportedInDelta(options);\n  const multicallHandlers = constructGetMulticallHandlers(options);\n\n  const approveTokenForDelta = constructApproveTokenForDelta(options);\n\n  const deltaOrdersSubmit = constructSubmitDeltaOrder(options);\n\n  const deltaOrdersBuild = constructBuildDeltaOrder(options);\n  const deltaOrdersSign = constructSignDeltaOrder(options);\n  const deltaOrdersPost = constructPostDeltaOrder(options);\n\n  return {\n    ...deltaOrdersGetters,\n    ...deltaOrdersContractGetter,\n    ...deltaPrice,\n    ...partnerFee,\n    ...bridgeInfo,\n    ...isTokenSupportedInDelta,\n    ...multicallHandlers,\n    ...approveTokenForDelta,\n    ...deltaOrdersSubmit,\n    ...deltaOrdersBuild,\n    ...deltaOrdersSign,\n    ...deltaOrdersPost,\n  };\n};\n","import type {\n  ConstructProviderFetchInput,\n  RequestParameters,\n} from '../../types';\nimport type { NFTOrderToSend, NFTOrderFromAPI } from './helpers/types';\nimport {\n  BuildNFTOrderFunctions,\n  BuildNFTOrderInput,\n  constructBuildNFTOrder,\n} from './buildOrder';\nimport {\n  CancelNFTOrderFunctions,\n  constructCancelNFTOrder,\n} from './cancelOrder';\nimport { constructGetNFTOrders, GetNFTOrdersFunctions } from './getOrders';\nimport { constructPostNFTOrder, PostNFTOrderFunctions } from './postOrder';\nimport { constructSignNFTOrder, SignNFTOrderFunctions } from './signOrder';\nimport {\n  constructApproveTokenForNFTOrder,\n  ApproveTokenForNFTOrderFunctions,\n} from './approveForOrder';\nimport {\n  GetNFTOrdersContractFunctions,\n  constructGetNFTOrdersContract,\n} from './getOrdersContract';\nimport {\n  BuildNFTOrdersTxFunctions,\n  constructBuildNFTOrderTx,\n} from './transaction';\n\ntype SubmitNFTOrder = (\n  buildNFTOrderParams: BuildNFTOrderInput,\n  extra?: { permitMakerAsset?: string },\n  requestParams?: RequestParameters\n) => Promise<NFTOrderFromAPI>;\n\nexport type SubmitNFTOrderFuncs = {\n  submitNFTOrder: SubmitNFTOrder;\n  submitP2POrder: SubmitNFTOrder;\n};\n\nexport const constructSubmitNFTOrder = (\n  options: ConstructProviderFetchInput<any, 'signTypedDataCall'>\n): SubmitNFTOrderFuncs => {\n  const { buildNFTOrder } = constructBuildNFTOrder(options);\n  const { signNFTOrder } = constructSignNFTOrder(options);\n  const { postNFTLimitOrder, postNFTP2POrder } = constructPostNFTOrder(options);\n\n  const prepareNFTOrder = async (\n    buildNFTOrderParams: BuildNFTOrderInput,\n    extra?: { permitMakerAsset?: string }\n  ): Promise<NFTOrderToSend> => {\n    const orderData = await buildNFTOrder(buildNFTOrderParams);\n    const signature = await signNFTOrder(orderData);\n\n    const orderWithSignature: NFTOrderToSend = {\n      ...orderData.data,\n      ...extra,\n      signature,\n    };\n\n    return orderWithSignature;\n  };\n\n  const submitNFTOrder: SubmitNFTOrder = async (\n    buildNFTOrderParams,\n    extra = {},\n    requestParams\n  ) => {\n    const orderWithSignature: NFTOrderToSend = await prepareNFTOrder(\n      buildNFTOrderParams,\n      extra\n    );\n\n    const newOrder = await postNFTLimitOrder(orderWithSignature, requestParams);\n\n    return newOrder;\n  };\n\n  const submitP2POrder: SubmitNFTOrder = async (\n    buildNFTOrderParams,\n    extra = {},\n    requestParams\n  ) => {\n    const orderWithSignature: NFTOrderToSend = await prepareNFTOrder(\n      buildNFTOrderParams,\n      extra\n    );\n\n    const newOrder = await postNFTP2POrder(orderWithSignature, requestParams);\n\n    return newOrder;\n  };\n\n  return { submitNFTOrder, submitP2POrder };\n};\n\nexport type NFTOrderHandlers<T> = SubmitNFTOrderFuncs &\n  BuildNFTOrderFunctions &\n  SignNFTOrderFunctions &\n  PostNFTOrderFunctions &\n  GetNFTOrdersFunctions &\n  GetNFTOrdersContractFunctions &\n  BuildNFTOrdersTxFunctions &\n  CancelNFTOrderFunctions<T> &\n  ApproveTokenForNFTOrderFunctions<T>;\n\n/** @description construct SDK with every NFTOrders-related method, fetching from API and contract calls */\nexport const constructAllNFTOrdersHandlers = <TxResponse>(\n  options: ConstructProviderFetchInput<\n    TxResponse,\n    'signTypedDataCall' | 'transactCall' | 'staticCall'\n  >\n): NFTOrderHandlers<TxResponse> => {\n  const NFTOrdersGetters = constructGetNFTOrders(options);\n  const NFTOrdersContractGetter = constructGetNFTOrdersContract(options);\n\n  const NFTOrdersSubmit = constructSubmitNFTOrder(options);\n  const NFTOrdersBuild = constructBuildNFTOrder(options);\n  const NFTOrdersSign = constructSignNFTOrder(options);\n  const NFTOrdersPost = constructPostNFTOrder(options);\n\n  const NFTOrdersCancel = constructCancelNFTOrder(options);\n  const NFTOrdersApproveToken = constructApproveTokenForNFTOrder(options);\n\n  const NFTOrdersBuildTx = constructBuildNFTOrderTx(options);\n\n  return {\n    ...NFTOrdersGetters,\n    ...NFTOrdersContractGetter,\n    ...NFTOrdersSubmit,\n    ...NFTOrdersBuild,\n    ...NFTOrdersSign,\n    ...NFTOrdersPost,\n    ...NFTOrdersCancel,\n    ...NFTOrdersApproveToken,\n    ...NFTOrdersBuildTx,\n  };\n};\n","import type Web3 from 'web3';\nimport type { ContractTransaction as EthersV5ContractTransaction } from '@ethersproject/contracts';\n\nimport { API_URL, DEFAULT_VERSION, SwapSide } from '../constants';\n\nimport { SwapSDKMethods, constructSwapSDK } from '../methods/swap';\nimport { assert } from 'ts-essentials';\nimport {\n  constructAxiosFetcher,\n  constructFetchFetcher,\n  constructEthersV5ContractCaller,\n  constructEthersV6ContractCaller,\n  constructWeb3ContractCaller,\n  isFetcherError,\n  Web3UnpromiEvent,\n  EthersProviderDeps,\n} from '../helpers';\n\nimport { constructGetRate, type RateOptions } from '../methods/swap/rates';\nimport {\n  constructBuildTx,\n  type BuildOptions,\n  type TransactionParams,\n} from '../methods/swap/transaction';\nimport type {\n  AddressOrSymbol,\n  Token,\n  FetcherFunction,\n  ParaSwapVersionUnion,\n  Address,\n  PriceString,\n  OptimalRate,\n  TxSendOverrides,\n} from '../types';\nimport { constructGetBalances, type Allowance } from '../methods/swap/balance';\nimport type { AxiosRequirement } from '../helpers/fetchers/axios';\nimport { isDataWithError } from '../helpers/misc';\nimport { constructPartialSDK } from '../sdk/partial';\nimport { constructGetTokens } from '../methods/swap/token';\nimport { constructGetSpender } from '../methods/swap/spender';\nimport { constructGetAdapters } from '../methods/swap/adapters';\nimport { ContractTransactionResponse as EthersV6ContractTransactionResponse } from 'ethers';\n\nexport type APIError = {\n  message: string;\n  status?: number;\n  data?: any;\n};\ntype Fetch = typeof fetch;\n\ntype TxResponse =\n  | Web3UnpromiEvent\n  | EthersV5ContractTransaction\n  | EthersV6ContractTransactionResponse;\n\ntype LegacyOptions = {\n  chainId?: number;\n  apiURL?: string;\n  version?: ParaSwapVersionUnion;\n  apiKey?: string;\n  web3Provider?: Web3;\n  ethersDeps?: EthersProviderDeps; // need to be a provider with signer for approve requests\n  account?: Address;\n  axios?: AxiosRequirement;\n  fetch?: Fetch;\n};\n\n/** @deprecated */\nexport class ParaSwap {\n  sdk: Partial<SwapSDKMethods<TxResponse>> = {};\n  fetcher: FetcherFunction;\n\n  chainId: number;\n  apiURL: string;\n  version: ParaSwapVersionUnion;\n  web3Provider?: Web3;\n  ethersDeps?: EthersProviderDeps; // need to be a provider with signer for approve requests\n  account?: Address;\n\n  constructor({\n    chainId = 1,\n    apiURL = API_URL,\n    version = DEFAULT_VERSION,\n    apiKey,\n    web3Provider,\n    ethersDeps,\n    account,\n    axios,\n    fetch,\n  }: LegacyOptions) {\n    this.chainId = chainId;\n    this.apiURL = apiURL;\n    this.version = version;\n    this.web3Provider = web3Provider;\n    this.ethersDeps = ethersDeps;\n    this.account = account;\n\n    const fetcher = axios\n      ? constructAxiosFetcher(axios, { apiKey })\n      : fetch\n      ? constructFetchFetcher(fetch, { apiKey })\n      : null;\n\n    assert(fetcher, 'at least one fetcher is needed');\n    this.fetcher = fetcher;\n\n    if (!web3Provider && !ethersDeps) {\n      this.sdk = constructPartialSDK(\n        { fetcher, apiURL, version, apiKey, chainId },\n        constructGetBalances,\n        constructGetTokens,\n        constructGetSpender,\n        constructBuildTx,\n        constructGetAdapters,\n        constructGetRate\n      );\n\n      return;\n    }\n\n    const contractCaller = ethersDeps\n      ? 'ethersV6ProviderOrSigner' in ethersDeps\n        ? constructEthersV6ContractCaller(ethersDeps, account)\n        : constructEthersV5ContractCaller(ethersDeps, account)\n      : web3Provider\n      ? constructWeb3ContractCaller(web3Provider, account)\n      : null;\n\n    if (contractCaller) {\n      this.sdk = constructSwapSDK<TxResponse>({\n        fetcher,\n        contractCaller,\n        apiURL,\n        version,\n        chainId,\n      });\n    }\n  }\n\n  private static handleAPIError(e: unknown): APIError {\n    // @CONSIDER if some errors should not be replaced\n    if (!isFetcherError(e)) {\n      return { message: `Unknown error: ${e}` };\n    }\n\n    if (!e.response) {\n      return { message: e.message };\n    }\n\n    const { status, data } = e.response;\n\n    return {\n      status,\n      message: isDataWithError(data) ? data.error : e.message,\n      data,\n    };\n  }\n\n  private static async extractHashFromTxResponse(\n    txResponse: TxResponse\n  ): Promise<string> {\n    if ('once' in txResponse) {\n      return new Promise<string>((resolve, reject) => {\n        txResponse.once('transactionHash', resolve);\n        txResponse.once('error', reject);\n      });\n    }\n\n    const { hash } = await txResponse;\n    return hash;\n  }\n\n  setWeb3Provider(web3Provider: Web3, account?: string): this {\n    const contractCaller = constructWeb3ContractCaller(web3Provider, account);\n    const { apiURL, chainId, fetcher } = this;\n\n    this.sdk = constructSwapSDK({\n      fetcher,\n      contractCaller,\n      apiURL,\n      version: this.version,\n      chainId,\n    });\n\n    this.web3Provider = web3Provider;\n    this.ethersDeps = undefined;\n    this.account = account;\n\n    return this;\n  }\n\n  setEthersProvider(ethersDeps: EthersProviderDeps, account?: string): this {\n    const { apiURL, chainId, fetcher } = this;\n\n    if ('ethersV6ProviderOrSigner' in ethersDeps) {\n      const contractCaller = constructEthersV6ContractCaller(\n        ethersDeps,\n        account\n      );\n      this.sdk = constructSwapSDK({\n        fetcher,\n        contractCaller,\n        apiURL,\n        version: this.version,\n        chainId,\n      });\n    } else {\n      const contractCaller = constructEthersV5ContractCaller(\n        ethersDeps,\n        account\n      );\n      this.sdk = constructSwapSDK({\n        fetcher,\n        contractCaller,\n        apiURL,\n        version: this.version,\n        chainId,\n      });\n    }\n\n    this.web3Provider = undefined;\n    this.ethersDeps = ethersDeps;\n    this.account = account;\n\n    return this;\n  }\n\n  // @CONSIDER I still think there's no need for a class Token\n  async getTokens(): Promise<Token[] | APIError> {\n    assert(this.sdk.getTokens, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getTokens();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAdapters() {\n    assert(this.sdk.getAdapters, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAdapters();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getRateByRoute(\n    route: AddressOrSymbol[],\n    amount: PriceString,\n    userAddress?: Address,\n    side: SwapSide = SwapSide.SELL,\n    options?: RateOptions,\n    srcDecimals?: number,\n    destDecimals?: number\n  ): Promise<OptimalRate | APIError> {\n    assert(this.sdk.getRateByRoute, 'sdk must be initialized with a fetcher');\n    if (route.length < 2) {\n      return { message: 'Invalid Route' };\n    }\n\n    try {\n      return await this.sdk.getRateByRoute({\n        route,\n        amount,\n        userAddress,\n        side,\n        options,\n        srcDecimals,\n        destDecimals,\n      });\n    } catch (e) {\n      // @TODO this overrides any non FetchError,\n      // including Error('Invalid DEX list')\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getRate(\n    srcToken: AddressOrSymbol,\n    destToken: AddressOrSymbol,\n    amount: PriceString,\n    userAddress?: Address,\n    side: SwapSide = SwapSide.SELL,\n    options: RateOptions = {},\n    srcDecimals?: number,\n    destDecimals?: number\n  ): Promise<OptimalRate | APIError> {\n    assert(this.sdk.getRate, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getRate({\n        srcToken,\n        destToken,\n        amount,\n        userAddress,\n        side,\n        options,\n        srcDecimals,\n        destDecimals,\n      });\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async buildTx(\n    srcToken: Address,\n    destToken: Address,\n    srcAmount: PriceString,\n    destAmount: PriceString,\n    priceRoute: OptimalRate,\n    userAddress: Address,\n    partner?: string,\n    partnerAddress?: string,\n    partnerFeeBps?: number,\n    receiver?: Address,\n    options: BuildOptions = {},\n    srcDecimals?: number,\n    destDecimals?: number,\n    permit?: string,\n    deadline?: string\n  ): Promise<TransactionParams | APIError> {\n    assert(this.sdk.buildTx, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.buildTx(\n        {\n          srcToken,\n          destToken,\n          srcAmount,\n          destAmount,\n          priceRoute,\n          userAddress,\n          partner,\n          partnerAddress,\n          partnerFeeBps,\n          receiver,\n          srcDecimals,\n          destDecimals,\n          permit,\n          deadline,\n        },\n        options\n      );\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getTokenTransferProxy(_provider?: any): Promise<Address | APIError> {\n    assert(this.sdk.getSpender, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getSpender();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAllowances(\n    userAddress: Address,\n    tokenAddresses: Address[]\n  ): Promise<Allowance[] | APIError> {\n    assert(this.sdk.getAllowances, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAllowances(userAddress, tokenAddresses);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getAllowance(\n    userAddress: Address,\n    tokenAddress: Address\n  ): Promise<Allowance | APIError> {\n    assert(this.sdk.getAllowance, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAllowance(userAddress, tokenAddress);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async approveTokenBulk(\n    amount: PriceString,\n    userAddress: Address,\n    tokenAddresses: Address[],\n    /** @deprecated */\n    _provider?: any // not used, can't detect if Ethers or Web3 provider without importing them\n  ): Promise<string[] | APIError> {\n    // @TODO expand sendOptions\n    assert(\n      this.sdk.approveTokenBulk,\n      'sdk must be initialized with a provider'\n    );\n    try {\n      // @TODO allow to pass Web3 specific sendOptions ({from: userAddress})\n      const txResponses = await this.sdk.approveTokenBulk(\n        amount,\n        tokenAddresses\n      );\n\n      return await Promise.all(\n        txResponses.map(ParaSwap.extractHashFromTxResponse)\n      );\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async approveToken(\n    amount: PriceString,\n    userAddress: Address,\n    tokenAddress: Address,\n    /** @deprecated */\n    _provider?: any, // not used, can't detect if Ethers or Web3 provider without importing them\n    sendOptions?: Omit<TxSendOverrides, 'from'>\n  ): Promise<string | APIError> {\n    // @TODO expand sendOptions\n    assert(this.sdk.approveToken, 'sdk must be initialized with a provider');\n    try {\n      // @TODO allow to pass Web3 specific sendOptions ({from: userAddress})\n      const txResponse = await this.sdk.approveToken(\n        amount,\n        tokenAddress,\n        sendOptions\n      );\n\n      return await ParaSwap.extractHashFromTxResponse(txResponse);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getMarketNames(): Promise<string[] | APIError> {\n    assert(this.sdk.getAdapters, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getAdapters();\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getBalance(\n    userAddress: Address,\n    token: AddressOrSymbol\n  ): Promise<Token | APIError> {\n    assert(this.sdk.getBalance, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getBalance(userAddress, token);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n\n  async getBalances(userAddress: Address): Promise<Token[] | APIError> {\n    assert(this.sdk.getBalances, 'sdk must be initialized with a fetcher');\n    try {\n      return await this.sdk.getBalances(userAddress);\n    } catch (e) {\n      return ParaSwap.handleAPIError(e);\n    }\n  }\n}\n","import type { SDKConfig } from './partial';\nimport { constructSwapSDK, SwapSDKMethods } from '../methods/swap';\nimport {\n  constructAllLimitOrdersHandlers,\n  LimitOrderHandlers,\n} from '../methods/limitOrders';\nimport {\n  constructAllNFTOrdersHandlers,\n  NFTOrderHandlers,\n} from '../methods/nftOrders';\nimport {\n  constructAllDeltaOrdersHandlers,\n  DeltaOrderHandlers,\n} from '../methods/delta';\nimport {\n  constructGetQuote,\n  GetQuoteFunctions,\n} from '../methods/quote/getQuote';\nimport { ConstructBaseInput } from '../types';\nimport { API_URL, DEFAULT_VERSION } from '../constants';\n\nexport type AllSDKMethods<TxResponse> = {\n  swap: SwapSDKMethods<TxResponse>;\n  limitOrders: LimitOrderHandlers<TxResponse>;\n  nftOrders: NFTOrderHandlers<TxResponse>;\n  delta: DeltaOrderHandlers<TxResponse>;\n  quote: GetQuoteFunctions;\n} & Required<ConstructBaseInput>;\n\n/** @description construct SDK with every method, for swap and limitOrders */\nexport const constructFullSDK = <TxResponse = any>(\n  config: SDKConfig<TxResponse>\n): AllSDKMethods<TxResponse> => {\n  // include all available functions\n  const swap: SwapSDKMethods<TxResponse> = constructSwapSDK(config);\n  const limitOrders: LimitOrderHandlers<TxResponse> =\n    constructAllLimitOrdersHandlers(config);\n  const nftOrders: NFTOrderHandlers<TxResponse> =\n    constructAllNFTOrdersHandlers(config);\n  const delta: DeltaOrderHandlers<TxResponse> =\n    constructAllDeltaOrdersHandlers(config);\n  const quote = constructGetQuote(config);\n\n  return {\n    swap,\n    limitOrders,\n    nftOrders,\n    delta,\n    quote,\n    apiURL: config.apiURL ?? API_URL,\n    chainId: config.chainId,\n    version: config.version ?? DEFAULT_VERSION,\n  };\n};\n","import { constructPartialSDK, SDKConfig } from './partial';\nimport {\n  GetAdaptersFunctions,\n  constructGetAdapters,\n} from '../methods/swap/adapters';\nimport {\n  GetBalancesFunctions,\n  constructGetBalances,\n} from '../methods/swap/balance';\nimport { GetRateFunctions, constructGetRate } from '../methods/swap/rates';\nimport {\n  GetSpenderFunctions,\n  constructGetSpender,\n} from '../methods/swap/spender';\nimport { GetTokensFunctions, constructGetTokens } from '../methods/swap/token';\nimport {\n  BuildTxFunctions,\n  constructBuildTx,\n} from '../methods/swap/transaction';\nimport { constructSwapTx, GetSwapTxFunctions } from '../methods/swap/swapTx';\n\nimport {\n  constructAxiosFetcher,\n  constructFetchFetcher,\n  constructEthersV5ContractCaller,\n  constructEthersV6ContractCaller,\n  constructWeb3ContractCaller,\n  constructViemContractCaller,\n} from '../helpers';\n\nimport type {\n  ConstructBaseInput,\n  ConstructFetchInput,\n  ContractCallerFunctions,\n  TransactionContractCallerFn,\n  TxHash,\n  Address,\n  FetcherFunction,\n  ExtraFetchParams,\n} from '../types';\n\nimport type { EthersProviderDeps, MinViemClient } from '../helpers';\nimport type Web3 from 'web3';\n\nimport type { SwapSDKMethods } from '../methods/swap';\nimport {\n  BuildLimitOrderFunctions,\n  constructBuildLimitOrder,\n} from '../methods/limitOrders/buildOrder';\nimport {\n  constructPostLimitOrder,\n  PostLimitOrderFunctions,\n} from '../methods/limitOrders/postOrder';\nimport {\n  constructGetLimitOrders,\n  GetLimitOrdersFunctions,\n} from '../methods/limitOrders/getOrders';\nimport {\n  constructGetLimitOrdersContract,\n  GetLimitOrdersContractFunctions,\n} from '../methods/limitOrders/getOrdersContract';\nimport {\n  constructBuildLimitOrderTx,\n  BuildLimitOrdersTxFunctions,\n} from '../methods/limitOrders/transaction';\nimport {\n  constructAllLimitOrdersHandlers,\n  LimitOrderHandlers,\n} from '../methods/limitOrders';\n\nimport {\n  constructGetNFTOrdersContract,\n  GetNFTOrdersContractFunctions,\n} from '../methods/nftOrders/getOrdersContract';\nimport {\n  constructGetNFTOrders,\n  GetNFTOrdersFunctions,\n} from '../methods/nftOrders/getOrders';\nimport {\n  BuildNFTOrderFunctions,\n  constructBuildNFTOrder,\n} from '../methods/nftOrders/buildOrder';\nimport {\n  constructPostNFTOrder,\n  PostNFTOrderFunctions,\n} from '../methods/nftOrders/postOrder';\nimport {\n  constructBuildNFTOrderTx,\n  BuildNFTOrdersTxFunctions,\n} from '../methods/nftOrders/transaction';\nimport {\n  constructAllNFTOrdersHandlers,\n  NFTOrderHandlers,\n} from '../methods/nftOrders';\n\nimport { constructSwapSDK } from '../methods/swap';\nimport type { AxiosRequirement } from '../helpers/fetchers/axios';\nimport { API_URL, DEFAULT_VERSION } from '../constants';\nimport {\n  constructAllDeltaOrdersHandlers,\n  DeltaOrderHandlers,\n} from '../methods/delta';\nimport {\n  BuildDeltaOrderFunctions,\n  constructBuildDeltaOrder,\n} from '../methods/delta/buildDeltaOrder';\nimport {\n  constructGetDeltaOrders,\n  GetDeltaOrdersFunctions,\n} from '../methods/delta/getDeltaOrders';\nimport {\n  constructGetDeltaPrice,\n  GetDeltaPriceFunctions,\n} from '../methods/delta/getDeltaPrice';\nimport {\n  constructGetDeltaContract,\n  GetDeltaContractFunctions,\n} from '../methods/delta/getDeltaContract';\nimport {\n  constructGetPartnerFee,\n  GetPartnerFeeFunctions,\n} from '../methods/delta/getPartnerFee';\nimport {\n  constructPostDeltaOrder,\n  PostDeltaOrderFunctions,\n} from '../methods/delta/postDeltaOrder';\nimport {\n  constructGetQuote,\n  GetQuoteFunctions,\n} from '../methods/quote/getQuote';\nimport {\n  constructGetBridgeInfo,\n  GetBridgeInfoFunctions,\n} from '../methods/delta/getBridgeInfo';\nimport {\n  constructGetMulticallHandlers,\n  GetMulticallHandlersFunctions,\n} from '../methods/delta/getMulticallHandlers';\nimport {\n  constructIsTokenSupportedInDelta,\n  IsTokenSupportedInDeltaFunctions,\n} from '../methods/delta/isTokenSupportedInDelta';\n\nexport type SwapFetchMethods = GetBalancesFunctions &\n  GetTokensFunctions &\n  GetSpenderFunctions &\n  BuildTxFunctions &\n  GetAdaptersFunctions &\n  GetRateFunctions &\n  GetSwapTxFunctions;\n\nexport type LimitOrdersFetchMethods = GetLimitOrdersContractFunctions &\n  GetLimitOrdersFunctions &\n  BuildLimitOrderFunctions &\n  PostLimitOrderFunctions &\n  BuildLimitOrdersTxFunctions;\n\nexport type NFTOrdersFetchMethods = GetNFTOrdersContractFunctions &\n  GetNFTOrdersFunctions &\n  BuildNFTOrderFunctions &\n  PostNFTOrderFunctions &\n  BuildNFTOrdersTxFunctions;\n\nexport type DeltaFetchMethods = BuildDeltaOrderFunctions &\n  GetDeltaOrdersFunctions &\n  GetDeltaPriceFunctions &\n  GetDeltaContractFunctions &\n  GetPartnerFeeFunctions &\n  GetMulticallHandlersFunctions &\n  GetBridgeInfoFunctions &\n  IsTokenSupportedInDeltaFunctions &\n  PostDeltaOrderFunctions;\n\nexport type SimpleFetchSDK = {\n  swap: SwapFetchMethods;\n  limitOrders: LimitOrdersFetchMethods;\n  nftOrders: NFTOrdersFetchMethods;\n  delta: DeltaFetchMethods;\n  quote: QuoteFetchMethods;\n} & Required<ConstructBaseInput>;\n\nexport type QuoteFetchMethods = GetQuoteFunctions;\n\nexport type SimpleSDK = {\n  swap: SwapSDKMethods<TxHash>;\n  limitOrders: LimitOrderHandlers<TxHash>;\n  nftOrders: NFTOrderHandlers<TxHash>;\n  delta: DeltaOrderHandlers<TxHash>;\n  quote: QuoteFetchMethods;\n} & Required<ConstructBaseInput>;\n\nexport type FetcherOptions = (\n  | {\n      axios: AxiosRequirement;\n    }\n  | { fetch: typeof fetch }\n  | { fetcher: FetcherFunction }\n) &\n  ExtraFetchParams;\n\ntype SimpleOptions = ConstructBaseInput & FetcherOptions;\n\nexport type ProviderOptions = (\n  | EthersProviderDeps\n  | { web3: Web3 }\n  | { viemClient: MinViemClient }\n) & {\n  account: Address;\n};\n\nconst constructFetcher = (options: FetcherOptions): FetcherFunction => {\n  if ('axios' in options) {\n    return constructAxiosFetcher(options.axios, options);\n  }\n  if ('fetch' in options) {\n    return constructFetchFetcher(options.fetch, options);\n  }\n  return (params) => {\n    // adding apiKey to headers if it's provided\n    const headers = options?.apiKey\n      ? {\n          'X-API-KEY': options.apiKey,\n          ...params.headers,\n          ...params.requestParams?.headers,\n        }\n      : params.headers;\n\n    return options.fetcher({ ...params, headers });\n  };\n};\n\n/** @description construct SDK with methods that fetch from API and optionally with blockchain provider calling methods */\nexport function constructSimpleSDK(options: SimpleOptions): SimpleFetchSDK;\n\nexport function constructSimpleSDK(\n  options: SimpleOptions,\n  providerOptions: ProviderOptions\n): SimpleSDK;\nexport function constructSimpleSDK(\n  options: SimpleOptions,\n  providerOptions?: ProviderOptions\n): SimpleFetchSDK | SimpleSDK {\n  const fetcher = constructFetcher(options);\n\n  if (!providerOptions) {\n    const config: ConstructFetchInput = {\n      apiURL: options.apiURL,\n      chainId: options.chainId,\n      version: options.version,\n      fetcher,\n    };\n\n    // include all available functions that don't need `contractCaller`\n    const swap: SwapFetchMethods = constructPartialSDK(\n      config,\n      constructGetBalances,\n      constructGetTokens,\n      constructGetSpender,\n      constructBuildTx,\n      constructGetAdapters,\n      constructGetRate,\n      constructSwapTx\n    );\n\n    const limitOrders = constructPartialSDK(\n      config,\n      constructBuildLimitOrder,\n      constructPostLimitOrder,\n      constructGetLimitOrders,\n      constructGetLimitOrdersContract,\n      constructBuildLimitOrderTx\n    );\n\n    const nftOrders = constructPartialSDK(\n      config,\n      constructBuildNFTOrder,\n      constructPostNFTOrder,\n      constructGetNFTOrders,\n      constructGetNFTOrdersContract,\n      constructBuildNFTOrderTx\n    );\n\n    const delta = constructPartialSDK(\n      config,\n      constructBuildDeltaOrder,\n      constructPostDeltaOrder,\n      constructGetDeltaOrders,\n      constructGetDeltaPrice,\n      constructGetDeltaContract,\n      constructGetPartnerFee,\n      constructGetMulticallHandlers,\n      constructGetBridgeInfo,\n      constructIsTokenSupportedInDelta\n    );\n\n    const quote = constructPartialSDK(config, constructGetQuote);\n\n    return {\n      swap,\n      limitOrders,\n      nftOrders,\n      delta,\n      quote,\n      apiURL: options.apiURL ?? API_URL,\n      chainId: options.chainId,\n      version: options.version ?? DEFAULT_VERSION,\n    };\n  }\n\n  const contractCaller = constructSimpleContractCaller(providerOptions);\n\n  const config: SDKConfig<TxHash> = {\n    apiURL: options.apiURL,\n    version: options.version,\n    chainId: options.chainId,\n    fetcher,\n    contractCaller,\n  };\n\n  const swap: SwapSDKMethods<TxHash> = constructSwapSDK(config);\n\n  const limitOrders: LimitOrderHandlers<TxHash> =\n    constructAllLimitOrdersHandlers<TxHash>(config);\n\n  const nftOrders: NFTOrderHandlers<TxHash> =\n    constructAllNFTOrdersHandlers<TxHash>(config);\n\n  const delta: DeltaOrderHandlers<TxHash> =\n    constructAllDeltaOrdersHandlers<TxHash>(config);\n\n  const quote = constructGetQuote(config);\n\n  return {\n    swap,\n    limitOrders,\n    nftOrders,\n    delta,\n    quote,\n    apiURL: options.apiURL ?? API_URL,\n    chainId: options.chainId,\n    version: options.version ?? DEFAULT_VERSION,\n  };\n}\n\nfunction constructSimpleContractCaller(\n  providerOptions: ProviderOptions\n): ContractCallerFunctions<TxHash> {\n  if ('ethersProviderOrSigner' in providerOptions) {\n    const {\n      staticCall,\n      transactCall: _transactCall,\n      signTypedDataCall,\n    } = constructEthersV5ContractCaller(\n      providerOptions,\n      providerOptions.account\n    );\n\n    const transactCall: TransactionContractCallerFn<TxHash> = async (\n      params\n    ) => {\n      const contractTx = await _transactCall(params);\n\n      // as soon as tx is sent\n      // returning tx hash, it's up to the user to wait for tx\n      return contractTx.hash as TxHash;\n    };\n\n    return { staticCall, transactCall, signTypedDataCall };\n  }\n\n  if ('ethersV6ProviderOrSigner' in providerOptions) {\n    const {\n      staticCall,\n      transactCall: _transactCall,\n      signTypedDataCall,\n    } = constructEthersV6ContractCaller(\n      providerOptions,\n      providerOptions.account\n    );\n\n    const transactCall: TransactionContractCallerFn<TxHash> = async (\n      params\n    ) => {\n      const contractTx = await _transactCall(params);\n\n      // as soon as tx is sent\n      // returning tx hash, it's up to the user to wait for tx\n      return contractTx.hash as TxHash;\n    };\n\n    return { staticCall, transactCall, signTypedDataCall };\n  }\n\n  if ('viemClient' in providerOptions) {\n    const contractCaller = constructViemContractCaller(\n      providerOptions.viemClient,\n      providerOptions.account\n    );\n    return contractCaller;\n  }\n\n  const {\n    staticCall,\n    transactCall: _transactCall,\n    signTypedDataCall,\n  } = constructWeb3ContractCaller(\n    providerOptions.web3,\n    providerOptions.account\n  );\n\n  const transactCall: TransactionContractCallerFn<TxHash> = async (params) => {\n    const unpromiEvent = await _transactCall(params);\n\n    // as soon as tx is sent\n    // returning tx hash, it's up to the user to wait for tx\n    return new Promise<TxHash>((resolve, reject) => {\n      unpromiEvent.once('transactionHash', (hash) => resolve(hash as TxHash));\n      unpromiEvent.once('error', reject);\n    });\n  };\n\n  return { staticCall, transactCall, signTypedDataCall };\n}\n"],"names":["API_URL","DEFAULT_VERSION","constructSearchString","queryOptions","queryEntries","Object","entries","filter","_ref","undefined","map","_ref2","String","queryString","URLSearchParams","toString","isFetcherError","error","FetcherError","_Error","_ref3","_this","code","request","response","isAxiosError","message","call","this","status","Error","captureStackTrace","name","constructor","_assertThisInitialized","data","isDataWithError","_wrapNativeSuper","obj","isFilledArray","array","length","getRandomInt","Math","floor","random","Number","MAX_SAFE_INTEGER","runOnceAndCache","func","result","_result","apply","arguments","constructGetSpender","_ref$apiURL","apiURL","_ref$version","version","fetcher","fetchURL","network","chainId","_getContracts","_asyncToGenerator","_regeneratorRuntime","mark","_callee","requestParams","wrap","_context","prev","next","url","method","abrupt","sent","stop","_x","getContracts","getSpender","_callee2","_context2","TokenTransferProxy","_x2","getAugustusSwapper","_ref4","_callee3","_context3","AugustusSwapper","_x3","getAugustusRFQ","_ref5","_callee4","_context4","AugustusRFQ","_x4","MinERC20Abi","constant","inputs","type","outputs","payable","stateMutability","approveTokenMethodFactory","contractCaller","amount","tokenAddress","overrides","spender","transactCall","address","abi","contractMethod","args","constructApproveToken","options","_constructGetSpender","approveToken","approveTokenBulk","tokenAddresses","Promise","all","constructToken","tokenProps","_tokenProps$tokenType","tokenType","_tokenProps$mainConne","mainConnector","_tokenProps$connector","connectors","connectorsInput","_tokenProps$network","rest","_objectWithoutPropertiesLoose","_excluded","_extends","NOT_FOUND_RESPONSE","constructGetBalances","tokensUrl","getBalances","userAddress","tokens","getBalance","tokenAddressOrSymbol","token","_x5","getAllowances","tokenAddressesLowercaseSet","allowances","Set","toLowerCase","has","_ref5$allowance","allowance","_x6","_x7","_x8","getAllowance","_ref6","balanceOrNotFound","_balanceOrNotFound$al","_x9","_x10","_x11","constructGetAdapters","getAdapters","query","normalizeRateOptions","_ref$options","restInput","excludePricingMethods","excludeContractMethods","includeContractMethods","partner","includeDEXS","excludeDEXS","excludePools","restOptions","_excluded2","_map","join","transformed","PricingMethod","constructGetRate","pricesUrl","getRate","srcToken","destToken","parsedOptions","search","priceRoute","getRateByRoute","route","_route","constructSwapTx","getSwapTxData","constructGetTokens","getTokens","ZERO_ADDRESS","baseFetchUrlGetterFactory","orderKind","orderURLpart","sanitizeOrderData","nonceAndMeta","expiry","makerAsset","takerAsset","maker","taker","makerAmount","takerAmount","constructBaseFetchUrlGetter","OrderNFT","buildOrderData","verifyingContract","_ref$nonce","nonce","_makerAssetAddress","_takerAssetAddress","makerAssetId","_ref$takerAssetId","takerAssetId","makerAssetType","takerAssetType","AugustusAddress","_ref$taker","BigInt","assetAddressToUint","types","domain","assetAddress","assetType","_makerAsset","_takerAsset","startsWith","constructBuildTx","transactionsURL","buildTx","params","_params$takeSurplus","side","AmountMismatchError","sanitizedParams","takeSurplus","fetchParams","SwapSide","SELL","assert","areAmountsCorrect","queryParams","orders","order","sanitizedOrder","sanitizeNFTOrderData","sanitizeLimitOrderData","signature","permitMakerAsset","positiveSlippageToUser","slippage","BUY","destAmount","srcAmount","Order","takerInNonce","contractTaker","AppVersion","constructBuildLimitOrder","buildLimitOrder","buildLimitOrderParams","_options$version","_yield$getContracts","constructSignLimitOrder","signLimitOrder","typedData","typedDataOnly","signTypedDataCall","MinAugustusRFQAbi","internalType","constructCancelLimitOrder","cancelLimitOrder","orderHash","cancelLimitOrderBulk","orderHashes","splitSignature","slice","bytes","Uint8Array","i","parseInt","s","v","r","Array","from","b","padStart","sBytes","compact","encodeEIP_2612PermitFunctionInput","owner","value","deadline","_splitSignature","permitSignature","encodeAddress","encodeUint256","encodeUint8","encodeBytes32","val","encodeDAIlikePermitFunctionInput","holder","_splitSignature2","encodedHolder","encodedSpender","encodedNonce","encodedExpiry","encodedV","encodedR","encodedS","replace","components","constructFillOrderDirectly","fillOrderDirectly","takerPermit","permitTakerAsset","encodedPermitParams","isDaiPermit","constructGetLimitOrders","getBaseFetchURLByEntityType","getLimitOrders","userParams","baseFetchURL","userURL","offset","limit","hideSmallBalances","orderBy","getRequiredBalance","getLimitOrderByHash","constructPostLimitOrder","getBaseFetchURLByOrderType","postTypedOrder","limitOrderWithSignatureAndPermit","postLimitOrder","postP2POrder","constructApproveTokenForLimitOrder","approveMakerTokenForLimitOrder","approveTakerTokenForFillingP2POrderDirectly","approveTakerTokenForLimitOrder","constructGetLimitOrdersContract","getLimitOrdersContract","getTokenTransferProxy","constructBuildLimitOrderTx","buildSwapTx","getSwapAndLimitOrderRate","getLimitOrdersRate","_ref2$options","_options","_checkAndParseOrders","totalTakerAmount","takerAmountString","rateInput","checkAndParseOrders","ContractMethod","simpleBuy","buildLimitOrderTx","_checkAndParseOrders2","fillParams","buildSwapAndLimitOrderTx","_checkAndParseOrders3","destDecimals","_orders$reduce","reduce","accum","takerAssetsSet","add","makerAssetsSet","size","_orders$","constructBuildNFTOrder","buildNFTOrder","buildNFTOrderParams","constructSignNFTOrder","signNFTOrder","constructCancelNFTOrder","_constructCancelLimit","cancelNFTOrder","cancelNFTOrderBulk","constructGetNFTOrders","getNFTOrders","getNFTOrderByHash","constructPostNFTOrder","NFTOrderWithSignatureAndPermit","postNFTLimitOrder","postNFTP2POrder","constructGetNFTOrdersContract","getNFTOrdersContract","MinNFTAbi","constructApproveTokenForNFTOrder","approveERC20ForNFTOrder","approveNFTForNFTOrder","constructBuildNFTOrderTx","getSwapAndNFTOrderRate","getNFTOrdersRate","buildNFTOrderTx","buildSwapAndNFTOrderTx","uintToAssetAddress","assetUint","constructFetcher","axios","extra","headers","allParams","apiKey","t0","fetch","body","POSTheaders","apiHeaders","JSON","stringify","json","ok","statusText","fromEntries","config","constructEthersV5ContractCaller","account","providerOrSigner","ethersProviderOrSigner","Contract","EthersContract","staticCall","_contract$callStatic","contract","block","gas","restOverrides","normalizedOverrides","assertEthersContractHasMethodsV5","blockTag","gasLimit","callStatic","concat","callOverrides","signer","txOverrides","isEthersProviderWithSigner","isEthersSigner","getSigner","isTypedDataCapableSigner","_signTypedData","_isProvider","isEthersProvider","_isSigner","ethersContractHasMethodsV5","_len","methods","_key","every","_len2","_key2","constructContractCaller","ethersV6ProviderOrSigner","EthersV6Contract","callableContractFunction","getFunction","send","signTypedData","baseTypeRegex","findPrimaryType","candidates","keys","candidatesSet","forEach","candidate","typedDataFields","_type$match","baseType","match","primaryType","web3","_contract$methods","currentProvider","assertWeb3ContractHasMethods","eth","_contract$methods2","_from","preparedCall","promiEvent","unpromiEvent","on","bind","once","_typedData","EIP712Domain","web3ContractHasMethods","viemClient","readContract","blockNumber","functionName","_overrides$gas","_overrides$value","viemTxParams","gasPriceParams","writeContract","txParamsToViemTxParams","to","maxFeePerGas","maxPriorityFeePerGas","gasPrice","argsToViemArgs","viemDomain","salt","txParams","arg","asNumber","isNaN","constructGetDeltaContract","getDeltaContract","ParaswapDelta","constructGetPartnerFee","partnerFeeUrl","cachedPartnerFee","Map","getPartnerFee","get","set","composeDeltaOrderPermit","permit","nonceBuffer","buffer","nonceHex","uintTo32ByteArrayBuffer","signatureBuffer","hexString","byteArray","hexToByteArray","packedBuffer","encodePermit2Transfer","SWAP_ORDER_EIP_712_TYPES","Bridge","buildDeltaSignableOrderData","_ref2$beneficiary","beneficiary","expectedDestAmount","_ref2$deadline","Date","now","_ref2$nonce","_ref2$permit","partnerAddress","partnerFeeBps","_ref2$partnerTakesSur","partnerTakesSurplus","paraswapDeltaAddress","bridge","orderInput","partnerAndFee","producePartnerAndFee","toFixed","DEFAULT_BRIDGE","maxRelayerFee","destinationChainId","outputToken","multiCallHandler","constructBuildDeltaOrder","buildDeltaOrder","_options$partnerFeeBp","_options$nonce","feeOrTakeSurplusSupplied","_partnerAddress","_partnerFeeBps","_partnerTakesSurplus","partnerFeeResponse","input","deltaPrice","partnerFee","constructPostDeltaOrder","postOrderUrl","postDeltaOrder","postData","deltaOrderToPost","sanitizeDeltaOrderData","constructSignDeltaOrder","signDeltaOrder","constructGetDeltaPrice","_getDeltaPrice","price","getDeltaPrice","constructGetDeltaOrders","baseUrl","getDeltaOrderById","orderId","getDeltaOrderByHash","getDeltaOrders","page","constructApproveTokenForDelta","getParaswapDelta","deltaContract","approveTokenForDelta","constructGetBridgeInfo","bridgeInfoUrl","getBridgeInfo","supportedTokens","constructGetMulticallHandlers","multicallHandlersUrl","_getMulticallHandlers","getMulticallHandlers","constructIsTokenSupportedInDelta","isTokenSupportedInDelta","supported","constructGetQuote","_getQuote","getQuote","constructPartialSDK","_config$apiURL","_config$version","funcs","sdkSlice","assign","constructSwapSDK","constructSubmitLimitOrder","_constructPostLimitOr","prepareLimitOrder","orderData","orderWithSignature","submitLimitOrder","submitP2POrder","constructAllLimitOrdersHandlers","constructSubmitDeltaOrder","submitDeltaOrder","orderParams","partiallyFillable","constructAllDeltaOrdersHandlers","deltaOrdersGetters","constructSubmitNFTOrder","_constructPostNFTOrde","prepareNFTOrder","submitNFTOrder","constructAllNFTOrdersHandlers","NFTOrdersGetters","ParaSwap","_ref$chainId","web3Provider","ethersDeps","sdk","constructAxiosFetcher","constructFetchFetcher","constructEthersV6ContractCaller","constructWeb3ContractCaller","handleAPIError","e","_e$response","extractHashFromTxResponse","_extractHashFromTxResponse","txResponse","resolve","reject","hash","_proto","prototype","setWeb3Provider","setEthersProvider","_getTokens","_getAdapters","_getRateByRoute","srcDecimals","_getRate","_callee5","_context5","_x12","_x13","_x14","_x15","_x16","_buildTx","_callee6","receiver","_context6","_x17","_x18","_x19","_x20","_x21","_x22","_x23","_x24","_x25","_x26","_x27","_x28","_x29","_x30","_x31","_getTokenTransferProxy","_callee7","_provider","_context7","_x32","_getAllowances","_callee8","_context8","_x33","_x34","_getAllowance","_callee9","_context9","_x35","_x36","_approveTokenBulk","_callee10","txResponses","_context10","_x37","_x38","_x39","_x40","_approveToken","_callee11","sendOptions","_context11","_x41","_x42","_x43","_x44","_x45","getMarketNames","_getMarketNames","_callee12","_context12","_getBalance","_callee13","_context13","_x46","_x47","_getBalances","_callee14","_context14","_x48","ERC20","ERC1155","ERC721","swap","limitOrders","nftOrders","delta","quote","providerOptions","_options$apiURL2","_options$version2","_params$requestParams","_options$apiURL","_constructEthersV5Con","_transactCall","contractTx","_constructEthersV6Con","constructViemContractCaller","_constructWeb3Contrac","constructSimpleContractCaller"],"mappings":"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"}